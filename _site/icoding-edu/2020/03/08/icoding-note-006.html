<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Favicon Icon -->
    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico">

    <title> 飞天班第6节：深入JVM系列（上） - 大伟的博客 </title>
    <meta name="keywords" content="jvm">
    <meta name="description"
          content="JVM的位置，JVM架构图，类加载过程，加载static,加载final常量池，Native方法，程序计数器，方法区的前世今生，理解栈帧，堆的新生区、养老区、永久区（1.7前），元空间（1.8），jvm分析常用命令，Dump内存快照分析工具jconsole,jprofile">

    <link rel="canonical" href="http://47.113.95.179/jk-blog/icoding-edu/2020/03/08/icoding-note-006.html">
    <link rel="alternate" type="application/rss+xml" title="大伟,专注Spring Boot,Spring Cloud,Docker,Java后端技术" href="http://47.113.95.179/jk-blog/feed.xml">

    <!-- Third-Party CSS -->
    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/bower_components/octicons/octicons/octicons.css">
    <link rel="stylesheet" href="/bower_components/hover/css/hover-min.css">
    <link rel="stylesheet" href="/bower_components/primer-markdown/dist/user-content.min.css">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" href="/assets/css/gitalk.css">
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->

    

    <!-- My CSS -->
    <link rel="stylesheet" href="/assets/css/common.css">

    <!-- CSS set in page -->
    

    <!-- CSS set in layout -->
    
    <link rel="stylesheet" href="/assets/css/sidebar-post-nav.css">
    

    <!--<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">-->

    <script type="text/javascript" src="/bower_components/jquery/dist/jquery.min.js"></script>
    <script type="text/javascript" src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/lock.js"></script>
</head>


    <body>

    <header class="site-header">
    <div class="site-header-topbar">
        <div class="container">
            <div class="topbar-menu">
                
                <div class="item">
                    <a href="/archives.html"
                       target="_self"
                       title="Archives">
                        Archives
                    </a>
                </div>
                
                <div class="item">
                    <a href="/linux.html"
                       target="_self"
                       title="Linux">
                        Linux
                    </a>
                </div>
                
                <div class="item">
                    <a href="/mysql.html"
                       target="_self"
                       title="Mysql">
                        Mysql
                    </a>
                </div>
                
                <div class="item">
                    <a href="/mongodb.html"
                       target="_self"
                       title="MongoB">
                        MongoB
                    </a>
                </div>
                
                <div class="item">
                    <a href="/mq.html"
                       target="_self"
                       title="MQ">
                        MQ
                    </a>
                </div>
                
                <div class="item">
                    <a href="/fastdfs.html"
                       target="_self"
                       title="FastDFS">
                        FastDFS
                    </a>
                </div>
                
                <div class="item">
                    <a href="/redis.html"
                       target="_self"
                       title="Redis">
                        Redis
                    </a>
                </div>
                
                <div class="item">
                    <a href="/elasticsearch.html"
                       target="_self"
                       title="ES">
                        ES
                    </a>
                </div>
                
                <div class="item">
                    <a href="/docker.html"
                       target="_self"
                       title="Docker">
                        Docker
                    </a>
                </div>
                
                <div class="item">
                    <a href="/k8s.html"
                       target="_self"
                       title="K8s">
                        K8s
                    </a>
                </div>
                
                <div class="item">
                    <a href="/architect.html"
                       target="_self"
                       title="架构师">
                        架构师
                    </a>
                </div>
                
                <div class="item">
                    <a href="/gitee.html"
                       target="_self"
                       title="开源项目">
                        开源项目
                    </a>
                </div>
                
                <div class="item">
                    <a href="/tool.html"
                       target="_self"
                       title="工具">
                        工具
                    </a>
                </div>
                
                <div class="item">
                    <a href="/life.html"
                       target="_self"
                       title="生活">
                        生活
                    </a>
                </div>
                
                <div class="item">
                    <a href="/say.html"
                       target="_self"
                       title="说说">
                        说说
                    </a>
                </div>
                
                <div class="item">
                    <a href="/link.html"
                       target="_self"
                       title="友链">
                        友链
                    </a>
                </div>
                
            </div>
        </div>
    </div>
    <div class="container">
        <a id="site-header-brand" href="/" title="大展宏兔">
            <!--<span class="octicon octicon-mark-github"></span>-->
            <img class="logo" src="/assets/images/favicon.jpeg">
            大展宏兔
        </a>
        <nav class="site-header-nav" role="navigation">
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/"
                   target=""
                   title="Home">
                    Home
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href=""
                   target=""
                   title="Icoding">
                    Icoding
                </a>
                
                <ul class="submenu">
                    
                    <li><a href="/icoding-edu.html" 
                           target="_self"
                     >飞天班笔记</a></li>
                    
                    <li><a href="/icoding-gavin.html" 
                           target="_self"
                     >黄埔班笔记</a></li>
                    
                    <li><a href="/icoding-allen.html" 
                           target="_self"
                     >源码分析</a></li>
                    
                    <li><a href="https://www.icodingedu.com/" 
                           target="_blank"
                     >艾编程官网</a></li>
                    
                    <li><a href="https://leetcode-cn.com/problemset/all/" 
                           target="_blank"
                     >力扣刷题</a></li>
                    
                </ul>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href=""
                   target=""
                   title="Java">
                    Java
                </a>
                
                <ul class="submenu">
                    
                    <li><a href="/java-base.html" 
                           target="_self"
                     >Java基础</a></li>
                    
                    <li><a href="/java-concurrent.html" 
                           target="_self"
                     >Java并发</a></li>
                    
                    <li><a href="/design-mode.html" 
                           target="_self"
                     >设计模式</a></li>
                    
                    <li><a href="http://www.justdojava.com" 
                           target="_blank"
                     >Java 极客技术</a></li>
                    
                </ul>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/spring.html"
                   target="_self"
                   title="Spring">
                    Spring
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/spring-boot.html"
                   target="_self"
                   title="Spring Boot">
                    Spring Boot
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/spring-cloud.html"
                   target="_self"
                   title="Spring Cloud">
                    Spring Cloud
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href=""
                   target=""
                   title="Go全栈">
                    Go全栈
                </a>
                
                <ul class="submenu">
                    
                    <li><a href="/go-base.html" 
                           target="_self"
                     >Go语言基础</a></li>
                    
                    <li><a href="/go-web.html" 
                           target="_self"
                     >Web开发</a></li>
                    
                    <li><a href="/go-middleware.html" 
                           target="_self"
                     >中间件</a></li>
                    
                </ul>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/front.html"
                   target="_self"
                   title="大前端">
                    大前端
                </a>
                
            </div>
            
        </nav>
    </div>
</header>


        <div class="content">
            <section class="jumbotron geopattern" data-pattern-id="飞天班第6节：深入JVM系列（上）">
    <div class="container">
        <div id="jumbotron-meta-info">        
            <h1>飞天班第6节：深入JVM系列（上）</h1>
            <span class="meta-info">
                
                
                <span class="octicon octicon-calendar"></span> 2020/03/08
                
            </span>
        </div>
    </div>
</section>
<script>
    $(document).ready(function(){

        $('.geopattern').each(function(){
            $(this).geopattern($(this).data('pattern-id'));
        });

    });
</script>
<article class="post container noneed" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="row">

        
        <div class="col-md-9 markdown-body">

            <h2 id="jvm面试题">JVM面试题</h2>

<blockquote>
  <p>常见的面试题</p>
</blockquote>

<p>1、请你谈谈你对JVM的理解？java8虚拟机有什么更新？</p>

<p>​		java8中移除了方法区的永久代实现，使用Metaspace(元空间)实现，元空间不在jvm中，仅受本地内存限制，可通过参数调整大小。</p>

<p>2、什么是OOM，请你说说OOM产生的原因？如何分析？</p>

<p>​	内存溢出OutOfMemeoryError(OOM),当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。利用jprofile dump文件分析OOM</p>

<p>​	<strong>最常见的OOM情况有以下三种：</strong></p>

<ul>
  <li>java.lang.OutOfMemoryError: Java heap space  ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</li>
  <li>java.lang.OutOfMemoryError: PermGen space  ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。加载大量的第三方包，也有可能会出现永久区溢出</li>
  <li>java.lang.StackOverflowError ——&gt; 不会抛OOM  error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</li>
</ul>

<p>3、JVM的常用调优参数有哪些？</p>

<ul>
  <li>
    <p>-XX:+HeapDumpOnOutOfMemoryError:让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</p>
  </li>
  <li>-Xms2g：初始化推大小为 2g；</li>
  <li>-Xmx2g：堆最大内存为 2g；</li>
  <li>-XX:MetaspaceSize=128m 设置元空间大小为128m</li>
  <li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
  <li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
  <li>-XX:MaxTenuringThreshold=15 设置新生代进入老年代的存活年限（默认是15）</li>
  <li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
  <li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
  <li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
  <li>-XX:+PrintGCDetails：打印 gc 详细信息</li>
  <li>-XX:+TraceClassLoading  追踪类的加载信息并打印出来</li>
  <li>-XX:+HeapDumpOnOutOfMemoryError dump堆内存溢出的异常分析文件</li>
</ul>

<p>4、内存快照抓取，如何分析，命令是什么？</p>

<p>使用Jconsole 和 Jprofiler 性能分析工具，dump内存快照JVM参数 -XX:+HeapDumpOnOutOfMemoryError</p>

<p>5、堆里面分区？Eden(伊甸园区)、Surival(幸存者区，细分为from 区 和 to 区)、养老区</p>

<p>逻辑上分为：新生区-&gt;养老区-&gt;永久区（jdk1.8中叫元空间），jdk1.8后，将永久区移除JVM，使用元空间的概念替代，元空间是在本地内存上的，不属于JVM，所以物理上堆分区只有：新生区、养老区。</p>

<p>新生区，又细分为Eden(伊甸园区)、Surival(幸存者区，细分为from 区 和 to 区)</p>

<p>6、GC垃圾收集算法有那几个？谈谈利弊？</p>

<ul>
  <li>
    <p>引用计数法，每次对象都会使用计算器，成本高，内存消耗大，一般不采用</p>
  </li>
  <li>
    <p>复制算法，内存效率整齐度高，适合新生区使用，好处是没有内存碎片，缺点是浪费一倍的内存空间</p>
  </li>
  <li>
    <p>标记清除整理算法，内存利用率高，没有内存碎片，缺点是耗时也可能比较严重，适合老年区使用，该算法分3步：</p>

    <ul>
      <li>
        <p>标记，扫描全部对象，标记能够存活的对象</p>
      </li>
      <li>清除没有被标记的对象</li>
      <li>整理，压缩空间，将存活的对象滑动到一侧</li>
    </ul>
  </li>
</ul>

<p>7、栈内存和堆内存的区别</p>

<p>栈内存：栈是管理程序运行的，存放函数中定义的一些基本类型的变量（int…double等) + 对象的引用变量(真实的对象信息在堆里面)</p>

<p>堆内存：存放着由new创建的对象和数组，类、方法、常量、保存了类型引用的真实信息；</p>

<p>方法区存储：类信息、常量池、静态变量、符号引用、方法代码</p>

<p><img src="/assets/images/2020/java/jvm-2.png" alt="" /></p>

<blockquote>
  <p>BAT 难度的面试题</p>
</blockquote>

<p><strong>1、JVM垃圾回收的时候如何确定，GC Roots?</strong></p>

<p>可达性分析算法，假设一个根能连到的对象都被判断是活着的对象，就是可达到，相反不可达的对象就会被回收，也就是与根对象没有关系的对象都会被回收</p>

<p>这里的根有4种情况，它可以是：</p>

<ul>
  <li>JVM栈中引用的对象（就是引用变量的真实对象）</li>
  <li>类中静态属性引用的对象</li>
  <li>方法区中的常量（常量池就是放在方法区中）</li>
  <li>本地方法栈中 Native 方法引用的对象！</li>
</ul>

<p><strong>2、-X,-XX参数你用过哪些？</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看帮助</span>
java <span class="nt">-X</span> <span class="nt">--help</span> 
xjwdeMacBook:~ xjw<span class="nv">$ </span>java <span class="nt">-X</span> <span class="nt">--help</span>
    <span class="nt">-Xmixed</span>           混合模式执行 <span class="o">(</span>默认<span class="o">)</span>
    <span class="nt">-Xint</span>             仅解释模式执行
    <span class="nt">-Xbootclasspath</span>:&lt;用 : 分隔的目录和 zip/jar 文件&gt;
                      设置搜索路径以引导类和资源
    <span class="nt">-Xbootclasspath</span>/a:&lt;用 : 分隔的目录和 zip/jar 文件&gt;
                      附加在引导类路径末尾
    <span class="nt">-Xbootclasspath</span>/p:&lt;用 : 分隔的目录和 zip/jar 文件&gt;
                      置于引导类路径之前
    <span class="nt">-Xdiag</span>            显示附加诊断消息
    <span class="nt">-Xnoclassgc</span>       禁用类垃圾收集
    <span class="nt">-Xincgc</span>           启用增量垃圾收集
    <span class="nt">-Xloggc</span>:&lt;file&gt;    将 GC 状态记录在文件中 <span class="o">(</span>带时间戳<span class="o">)</span>
    <span class="nt">-Xbatch</span>           禁用后台编译
    <span class="nt">-Xms</span>&lt;size&gt;        设置初始 Java 堆大小
    <span class="nt">-Xmx</span>&lt;size&gt;        设置最大 Java 堆大小
    <span class="nt">-Xss</span>&lt;size&gt;        设置 Java 线程堆栈大小
    <span class="nt">-Xprof</span>            输出 cpu 配置文件数据
    <span class="nt">-Xfuture</span>          启用最严格的检查, 预期将来的默认值
    <span class="nt">-Xrs</span>              减少 Java/VM 对操作系统信号的使用 <span class="o">(</span>请参阅文档<span class="o">)</span>
    <span class="nt">-Xcheck</span>:jni       对 JNI 函数执行其他检查
    <span class="nt">-Xshare</span>:off       不尝试使用共享类数据
    <span class="nt">-Xshare</span>:auto      在可能的情况下使用共享类数据 <span class="o">(</span>默认<span class="o">)</span>
    <span class="nt">-Xshare</span>:on        要求使用共享类数据, 否则将失败。
    <span class="nt">-XshowSettings</span>    显示所有设置并继续
    <span class="nt">-XshowSettings</span>:all
                      显示所有设置并继续
    <span class="nt">-XshowSettings</span>:vm 显示所有与 vm 相关的设置并继续
    <span class="nt">-XshowSettings</span>:properties
                      显示所有属性设置并继续
    <span class="nt">-XshowSettings</span>:locale
                      显示所有与区域设置相关的设置并继续
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 输出此帮助消息</span>
xjwdeMacBook:~ xjw<span class="nv">$ </span>java -?  
</code></pre></div></div>

<p><strong>3、你常用的项目，发布后配置过JVM调优参数吗?怎么设置元空间大小</strong>，怎么样设置幸存者区大小</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设置元空间大小</span>
<span class="nt">-XX</span>:MetasapceSize10m
</code></pre></div></div>

<p><strong>4、引用，强引用，弱引用，虚引用都是什么</strong>，请你谈谈</p>

<p><strong>5、GC垃圾回收器和GC算法的关系</strong>？分别有哪些？</p>

<p>GC垃圾回收器：串行垃圾回收器、并行垃圾回收器、并发垃圾回收器、G1垃圾回收器</p>

<ul>
  <li>
    <p>串行（STW：Stop the World）单线程</p>
  </li>
  <li>
    <p>并行垃圾回收器（多线程工作，也会导致 STW）</p>
  </li>
  <li>
    <p>并发垃圾回收器</p>

    <p>在回收垃圾的同时，可以正常执行线程，并行处理，但是如果是单核CPU，只能交替执行！</p>
  </li>
  <li>
    <p>G1垃圾回收器</p>

    <p>将堆内存分割成不同的区域，然后并发的对其进行垃圾回收</p>
  </li>
</ul>

<p>6、谈谈默认的垃圾回收器？</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 打印jvm的垃圾回收详情信息</span>
java <span class="nt">-XX</span>:+PrintGCDetails <span class="nt">-version</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-print-gcdetails.jpg" alt="" /></p>

<p>Heap(堆)</p>

<ul>
  <li>PSYoungGen(新生区)，细分为eden(伊甸园区)、from区、to区</li>
  <li>ParOldGen(养老区)</li>
  <li>Metaspace(元空间) ，逻辑上属于堆，物理上不属于堆</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 打印命令行的一些参数</span>
java <span class="nt">-XX</span>:+PrintCommandLineFlags <span class="nt">-version</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-print-commandlineflags.jpg" alt="" /></p>

<p>可以发现InitialHeapSize 初始化堆内存，MaxHeapSize 最大堆内存，-XX:+UseParallelGC 使用的垃圾回收器ParallelGC</p>

<p><strong>7、G1垃圾回收器的特点？</strong></p>

<p>8、OOM你看过几种？</p>

<p>内存溢出OutOfMemeoryError(OOM),当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。利用jprofile dump文件分析OOM</p>

<p>​	<strong>最常见的OOM情况有以下三种：</strong></p>

<ul>
  <li>java.lang.OutOfMemoryError: Java heap space  ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</li>
  <li>java.lang.OutOfMemoryError: PermGen space  ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</li>
  <li>java.lang.StackOverflowError ——&gt; 不会抛OOM  error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</li>
</ul>

<blockquote>
  <p>Java 混合模式(默认)</p>
</blockquote>

<p><img src="/assets/images/2020/java/java-version-mixed-mode.jpg" alt="" /></p>

<p>修改为<font color="red">解释执行</font>模式</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span> <span class="o">-</span><span class="nc">Xint</span> <span class="o">-</span><span class="n">version</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-interpreted-mode.jpg" alt="" /></p>

<p>修改为<font color="red">编译执行</font>模式</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span> <span class="o">-</span><span class="nc">Xcomp</span> <span class="o">-</span><span class="n">version</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-compiled-mode.jpg" alt="" /></p>

<blockquote>
  <p>深入学习</p>
</blockquote>

<p>一本书《深入理解JAVA虚拟机》</p>

<blockquote>
  <p>其他面试题</p>
</blockquote>

<ul>
  <li>
    <p>JVM 内存区域？</p>
  </li>
  <li>
    <p>三大常量池了解吗？</p>
  </li>
  <li>
    <p>堆内存结构？</p>

    <p>物理上由年轻代和老年代组成</p>
  </li>
  <li>
    <p>GC 算法-复制算法？</p>
  </li>
  <li>
    <p>GC 算法-标记整理？</p>
  </li>
  <li>
    <p>GC 算法-标记清除？</p>
  </li>
  <li>
    <p>三种算法优缺点比较？</p>

    <p>内存效率：复制算法 &gt; 标记清除 &gt; 标记整理</p>

    <p>内存整齐度：复制算法=标记整理&gt;标记清除</p>

    <p>内存利用率：标记整理 = 标记清除 &gt; 复制算法</p>

    <p>年轻代经常发生GC且对象存活率较低，使用复制算法；</p>

    <p>老年代不经常GC,使用标记整理算法</p>
  </li>
  <li>
    <p>老年代担保是什么</p>
  </li>
  <li>
    <p>Full GC 触发条件</p>

    <p>老年代空间不足</p>
  </li>
  <li>
    <p>OOM 问题怎么排查</p>

    <p>dump文件</p>
  </li>
  <li>
    <p>Dump日志分析工具</p>
  </li>
</ul>

<h2 id="0jvm的位置">0、JVM的位置</h2>

<p>每一个学习 JVM 的人，都渴望成功！</p>

<p>JVM 会了但是你也看不出来多少效果！</p>

<p>高级程序员甚至架构师，都必须要了解JVM ！</p>

<p><img src="/assets/images/2020/java/jvm.png" alt="" /></p>

<p>Java无法直接操作内存（硬件）</p>

<h2 id="1jvm体系架构图">1、JVM体系架构图</h2>

<p><img src="/assets/images/2020/java/jvm-arch.png" alt="" /></p>

<p>简化一下：</p>

<p><img src="/assets/images/2020/java/jvm-arch-simple2.gif" alt="" /></p>

<p><img src="/assets/images/2020/java/jvm-2.png" alt="" /></p>

<p>自己必须能够闭着眼睛想到这个图，方法在java1.7（含）前使用永久代实现，java1.8后使用元空间实现，元空间不在jvm中，仅受本地内存限制。</p>

<p>兴趣才是最好的老师，我老了也会敲代码，因为他是一辈子的兴趣</p>

<h2 id="2类加载器classloader">2、类加载器Classloader</h2>

<h3 id="类加载结构图">类加载结构图</h3>

<p>一个类加载到JVM的基本结构过程</p>

<p><img src="/assets/images/2020/juc/jvm-classloader.png" alt="" /></p>

<ul>
  <li>正向实例化</li>
  <li>反向，反射获取类模版，创建实例</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span> <span class="c1">// jdk 自带的</span>
        <span class="nc">Demo01</span> <span class="n">demo01</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Demo01</span><span class="o">();</span>  <span class="c1">// 正向创建，实例化一个自己定义的对象</span>

        <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Demo01</span><span class="o">&gt;</span> <span class="n">aClass</span> <span class="o">=</span> <span class="n">demo01</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span> <span class="c1">// 反射得到对象的Class模板</span>
        <span class="nc">ClassLoader</span> <span class="n">classLoader</span> <span class="o">=</span> <span class="n">aClass</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span><span class="c1">// 得到类加载器</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classLoader</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>  
</code></pre></div></div>

<p>执行结果：类加载器AppClassLoader</p>

<p><img src="/assets/images/2020/java/appclassloader.jpg" alt="" /></p>

<blockquote>
  <p>类的加载、连接和初始化（了解）</p>
</blockquote>

<p>运行期间完成</p>

<p>第一步加载：查找并加载类的二进制数据</p>

<p>第二步连接：</p>

<ul>
  <li>
    <p>验证：保证被加载的类的正确性；</p>
  </li>
  <li>
    <p>准备：给类静态变量分配内存空间，赋值一个默认的初始值:int 0；new() 不是一个原子性的操作</p>
  </li>
  <li>
    <p>解析：把类中的符号引用转换为直接引用</p>

    <p>在把java编译为class文件的时候，虚拟机并不知道所引用的地址；<mark>助记符</mark>：符号引用(代替真实的地址)！
转为真正的直接引用，找到对应的直接地址！</p>
  </li>
</ul>

<p>第三步初始化：给类的静态变量赋值正确的值（静态变量是基本类型或者字符串，被java编译器标记成常量值，初始化就直接被JVM完成）；</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
    <span class="c1">// public int a = 1; // 类实例化(new)才有的a</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 类初始化（类加载的时候），就初始化变量a,赋值</span>
  <span class="c1">// public static main (){....} 类初始化（类加载的时候），就初始化该方法</span>
<span class="o">}</span>

<span class="nc">Test</span><span class="o">.</span><span class="na">java</span><span class="err">文件进入类加载器的过程（原理）：</span>
<span class="c1">// 1、加载：</span>
  	<span class="err">编译文件为</span><span class="o">.</span><span class="na">class</span><span class="err">文件，通过类加载，加载到</span><span class="no">JVM</span>
<span class="c1">// 2、连接   </span>
	  <span class="err">验证</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>  <span class="err">保证</span><span class="n">Class</span><span class="err">类文件没有问题</span>
    <span class="err">准备</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>  <span class="err">给类静态变量分配内存空间，赋值一个默认的初始值，这里给</span><span class="n">int</span><span class="err">类型的变量</span> <span class="n">a</span><span class="err">分配内存空间并赋值</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="err">；</span>
    <span class="err">解析</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>  <span class="err">符号引用转换为直接引用</span>
<span class="c1">// 3、初始化：</span>
    <span class="err">给类的静态变量赋值正确的值，把</span><span class="mi">1</span><span class="err">赋值给变量</span><span class="n">a</span><span class="err">；</span>
  
  <span class="err">所以变量</span><span class="n">a</span><span class="err">的值一开始是</span><span class="mi">0</span><span class="err">，后来才被赋值为</span><span class="mi">1</span>
</code></pre></div></div>

<h3 id="类的加载static">类的加载static</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">coding</span><span class="o">.</span><span class="na">classloader</span><span class="o">;</span>

<span class="c1">// JVM 参数：</span>
<span class="c1">//  -XX:+TraceClassLoading // 用于追踪类的加载信息并打印出来</span>
<span class="c1">//  分析项目启动为什么这么慢，快速定位自己的类有没有被加载！</span>
<span class="c1">// rt.jar jdk 出厂自带的，最高级别的类加载器要加载的！（最优先）</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo02</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">MyChild1</span><span class="o">.</span><span class="na">str2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyParent1</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello,world"</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyParent1 static"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyChild1</span> <span class="kd">extends</span> <span class="nc">MyParent1</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"hello,str2"</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyChild1 static"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="err">执行结果：</span>
     <span class="nc">MyParent1</span> <span class="kd">static</span>
     <span class="nc">MyChild1</span> <span class="kd">static</span>
     <span class="n">hello</span><span class="o">,</span><span class="n">str2</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/vm-option-program-args.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/vm-option-2.jpg" alt="" /></p>

<p>执行，输出类加载的信息，首先加载的是rt.jar包 的内容</p>

<p><img src="/assets/images/2020/java/load-rt-jar.jpg" alt="" /></p>

<p>往下翻，最终加载我们自己的类Demo02 -&gt; MyParent1 -&gt; MyChild1，执行输出</p>

<p><img src="/assets/images/2020/java/load-myclass.jpg" alt="" /></p>

<p>以后分析项目启动为什么这么慢时候，通过追踪类加载信息，快速定位自己的类有没有被加载！</p>

<h3 id="类加载final常量池">类加载final常量池</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">coding</span><span class="o">.</span><span class="na">classloader</span><span class="o">;</span>

<span class="c1">// 常量，如果编译期间就确定的值就会在调用类加载的时候，放到调用类的常量池中，就不会去加载常量所在的类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">MyParent02</span><span class="o">.</span><span class="na">str</span><span class="o">);</span> <span class="c1">// 已确定的值，加载类Demo03的时候把它放进自己的常量池</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyParent02</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyParent02 static"</span><span class="o">);</span> <span class="c1">// 这句话会输出吗？</span>
    <span class="o">}</span>
    <span class="cm">/*
     final 常量在编译阶段的时候放入常量池，并不会加载类；
     这个代码中将常量放到了Demo03的常量池中。之后 Demo03与MyParent02 就没有关系了，
     Demo03从自己的常量池拿值，根本不需要去触发加载Myparent02，除非str是要运行才能确定的
     值，那么他就不会放进Demo03的常量池
     */</span>
<span class="o">}</span>
</code></pre></div></div>

<p>执行结果：</p>

<p><img src="/assets/images/2020/java/classloader-final.jpg" alt="" /></p>

<p>并没有打印“MyParent02 static”，因为加载类的Demo03的时候就已经将常量str放进了自己的常量池，因为str已经确定值，就不用去加载类MyParent02，前面我们使用JVM参数-XX:+TraceClassLoading 看到类加载的整个过程，现在我们也追踪一下Demo03的加载过程</p>

<p><img src="/assets/images/2020/java/classloader-static-final.jpg" alt="" /></p>

<p>发现只加载了Demo03就执行了输出，因为常量str的值在Demo03常量池就已经确定，就不需要去触发加载类MyParent02，完成Main主进程。</p>

<blockquote>
  <p>编译期间不确定的常量就不会放入调用类的常量池中</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">coding</span><span class="o">.</span><span class="na">classloader</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.UUID</span><span class="o">;</span>

<span class="cm">/**
 * 当一个常量的值并非编译期间可以确定的，那这个值就不会被放入调用类的常量池中！
 * 程序运行期间的时候，回主动使用常量所在的类
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">MyParent04</span><span class="o">.</span><span class="na">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyParent04</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyParent04 static"</span><span class="o">);</span> <span class="c1">// 这句话会输出吗？</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>同样我们加上JVM参数-XX:+TraceClassLoading 追踪类加载的过程 ，运行</p>

<p><img src="/assets/images/2020/java/classloader-static-final-2.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/classloader-static-final-3.jpg" alt="" /></p>

<p>可以看到加载类Demo04 -&gt; MyParent04 -&gt; UUID，既然加载了MyParent04，自然就会执行静态代码块，打印“MyParent04 static”</p>

<h3 id="classloader类加载分类4个">ClassLoader类加载分类4个</h3>

<p>1、java虚拟机自带的加载器（先天）</p>

<ul>
  <li>
    <p>BootStrap  根加载器（加载系统的包，JDK 核心库中的类  rt.jar）</p>
  </li>
  <li>
    <p>Ext      扩展类加载器 （加载一些扩展jar包中的类）在java的/ext目录下如下图，一些大的公司如腾讯，自己写一些类打成jar包放入ext中，优先级比自己写的java代码高，可以把类放入ext下避免被覆盖，它会优先加载</p>

    <p><img src="/assets/images/2020/java/ext.jpg" alt="" /></p>
  </li>
  <li>
    <p>Sys/App      系统（应用类）加载器 （我们自己编写的类）</p>
  </li>
</ul>

<p>2、用户自己定义的加载器(后天)</p>

<ul>
  <li>ClassLoader，只需要继承这个抽象类即可，自定义自己的类加载器</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">coding</span><span class="o">.</span><span class="na">classloader</span><span class="o">;</span>

<span class="c1">// Demo01</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span> <span class="c1">// jdk 自带的</span>
        <span class="nc">Demo01</span> <span class="n">demo01</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Demo01</span><span class="o">();</span>  <span class="c1">// 实例化一个自己定义的对象</span>

        <span class="c1">// null 在这里并不代表没有，只是Java触及不到！它的底层是C++写的，所以java触及不到</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">());</span> <span class="c1">// null</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">demo01</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">());</span> <span class="c1">// AppClassLoader</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">demo01</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">().</span><span class="na">getParent</span><span class="o">());</span> <span class="c1">// ExtClassLoader</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">demo01</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">().</span><span class="na">getParent</span><span class="o">().</span><span class="na">getParent</span><span class="o">());</span> <span class="c1">// null</span>

        <span class="c1">// 思考：为什么我们下面自己定义的java.lang.String 没有生效？</span>
      <span class="c1">// 因为：</span>
        <span class="c1">// jvm 中有机制可以保护自己的安全；</span>
        <span class="c1">// 双亲委派机制： 一层一层的让父类去加载，如果顶层的加载器不能加载，然后再向下类推</span>
        <span class="c1">// Demo01							04</span>
        <span class="c1">// AppClassLoader      03</span>
        <span class="c1">// ExtClassLoader      02</span>
        <span class="c1">// BootStrap (最顶层)   01  java.lang.String  对应rt.jar包 </span>

        <span class="c1">// 双亲委派机制 可以保护java的核心类不会被自己定义的类所替代，你自己定义的java.lang.String这个类是不生效的</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/classloaders.jpg" alt="" /></p>

<h3 id="双亲委派机制">双亲委派机制</h3>

<p><mark>双亲委派机制 可以保护java的核心类不会被自己定义的类所替代</mark></p>

<p>大概就是如果一个类加载器收到了类加载的请求，首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成。通过双亲委派机制就能保证同样一个类只被加载一次</p>

<p>一层一层的让父类去加载，如果顶层的加载器不能加载，然后再向下类推</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 自己定义一个类与java的核心类重复，看看会不会被覆盖</span>
<span class="kn">package</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">String</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>  
</code></pre></div></div>

<p>执行报错，因为真正运行的不是你这个类，是rt.jar包的java.lang.String，里面确实没有main方法</p>

<p><img src="/assets/images/2020/java/java-lang-main.jpg" alt="" /></p>

<p>在类加载最顶层BootStrap，也就是rt.jar包里，我们发现有个类java.lang.String,这个类里面根本没有main方法，所以执行的是这个类不是你自己定义的类，就报错没有main方法 ，<mark>这是双亲委派机制保护Java的核心类不会被自己定义的类锁替代</mark></p>

<p><img src="/assets/images/2020/java/rt-jar-lang-string.jpg" alt="" /></p>

<p><strong>生活中的例子</strong></p>

<p>比如说：公司部门有位程序员 A 发现如果做一个数据系统的话，来把公司各部门的数据打通，这样就可以减少很多交流成本，那么他可能就会和老大去说，申请去做这个系统，老大一看，这个方案完全可以抽成公共的呀，就自己去写了（父类加载公共方法），也可能老大一看，你就自己去写吧（父类不加载时，子类再进行加载），更巧的是，程序员 B 也发现了，他也去找老大说，这个时候老大会说什么呢？这个事情 A 去做了，就不用太担心了</p>

<p>那如果程序员 A 和 B 发现了之后没有和老大交流，都自己闷头去做了，这样的话，同样的系统做了两遍，还浪费了两个人的时间精力，由此造成的资源浪费太大了</p>

<p>我觉得双亲委派的机制类似于这样，因为这个机制的存在，让资源浪费的现象大大减少了。</p>

<h3 id="tomcat-打破双亲委派机制">tomcat 打破双亲委派机制</h3>

<p>我们都知道 tomcat 是个 web 容器，那么它应该：</p>

<ul>
  <li>
    <p>支持部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，就比如两个应用程序，其中一个依赖的是一个类库的 v1.0 ，另外一个依赖的是同样一个类库的 v2.0 ，那么 tomcat 是不是应该允许这个类库的 1.0 和 2.0 版本都存在？</p>
  </li>
  <li>部署在同一个 web 容器中相同的类库相同的版本是应该可以共享的。就比如，服务器上有 100 个应用程序，这些程序依赖的都是相同的类库，那 tomcat 总不能把这 100 份相同的类库都加载到虚拟机里面去吧，要是非要加载进去，那服务器不得分分钟炸了</li>
  <li>web 容器需要支持 jsp 文件的修改，也就是说，当程序运行之后，我对 jsp 文件进行了修改，那么 tomcat 是不是也应该支持？如果不支持的话，那我修改一次就不能用了，不合适吧</li>
</ul>

<p>基于上面三点，就能看到 tomcat 其实是打破了双亲委派机制的</p>

<ul>
  <li>
    <p>第一个问题，第三方类库就是同样一个资源，在双亲委派机制中，同样一个资源是不应该加载两次的，但是在 tomcat 里面却被允许了；</p>
  </li>
  <li>第二个问题好像又在说双亲委派的机制，正是因为双亲委派机制的存在，所以第二个问题就不是问题了嘛；</li>
  <li>第三个问题又打破了双亲委派机制，因为如果不打破的话，原来的 jsp 文件已经加载进来了，现在对它进行了修改，那么应该还会加载原来的 jsp 文件，这样的话修改岂不是无效了？</li>
</ul>

<p>所以， tomcat 打破了双亲委派机制，但并不是完全打破。</p>

<h2 id="3native方法">3、Native方法</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// java 真的可以开启线程吗？不能，是调用native 本地方法，调用底层C 去实现的</span>
        <span class="c1">// private native void start0();</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>点进start方法，底层调用的是native start0()</p>

<p><img src="/assets/images/2020/java/thread-start.jpg" alt="" /></p>

<p>加了native关键字的方法，一个native 方法就是一个java调用非java代码的接口，该方法的实现由非java语言实现，比如C。很多其他的编程语言都有这一机制，并非java特有，比如python会调用很多其他语言写的类库去实现功能。</p>

<font color="red">native : 只要是带了这个关键字的，说明 java的作用范围达不到，只能去调用底层 C 语言的库！</font>

<h3 id="robot类">Robot类</h3>

<p>闲谈：<mark>java.awt.Robot</mark>   按键精灵 !  默认鼠标键盘操作！java可以通过这个类实现一个简单的自动化脚本！它底层也是使用了native，通过本地方法接口操做鼠标</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span>
 <span class="n">mouse</span><span class="o">.</span><span class="na">move</span><span class="o">()</span>
<span class="n">loop</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/robot.jpg" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>

<span class="k">try</span> <span class="o">{</span>
  <span class="nc">Robot</span> <span class="n">robot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Robot</span><span class="o">();</span>
  <span class="c1">//robot.mouseMove(500,1000);</span>
  <span class="nc">Color</span> <span class="n">color</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="na">getPixelColor</span><span class="o">(</span><span class="mi">500</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">color</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
  <span class="n">robot</span><span class="o">.</span><span class="na">delay</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>

<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">AWTException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="jni">JNI</h3>

<p><strong>JNI ： Java Native Interface （Java 本地方法接口）</strong></p>

<p>为什么会有 Native 这个东西？</p>

<p>为什么有javascript，它跟java没有半毛钱关系，因为当时java很火，javascript为沾点关系所以改这个名字</p>

<blockquote>
  <p>故事</p>
</blockquote>

<p>1995年，全世界都在写c、c++、vb，java刚出来要生存下来那么必须可以去调用 c、c++的库，所以说Java就在内存中专门开辟了一块区域标记为 native 方法</p>

<p>本地方法栈：null，因为java触及不到了，调用的是c、c++的库</p>

<p>现在的通信：Socket、WebService…，企业开发中很少用到native去开发了</p>

<h2 id="4程序计数器">4、程序计数器</h2>

<p><mark>每个线程都有一个程序计数器，是线程私有的。</mark>看JVM的体系架构图</p>

<p>程序计数器就是一块十分小的内存空间(几乎可以不计大小)。</p>

<p>作用：看做当前字节码的行号指示器</p>

<p>下图左边部分是字节码文件，通过javap -c 命令 class文件得到代码语句的执行顺序，如下图</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javap <span class="nt">-c</span> Calc.class
</code></pre></div></div>

<p><img src="/assets/images/2020/java/pc-registor.png" alt="" /></p>

<p>代码解析：分支、循环、跳转、异常处理！都需要依赖于程序计数器来完成</p>

<p><mark>bipush</mark>  将 int、float、String、常量值推送值栈顶；</p>

<p><mark>istore</mark> 将一个数值从操作数栈存储到局部变量表；</p>

<p><mark>iadd </mark>  加</p>

<p><mark>imul</mark> 乘</p>

<p>当一个线程的cpu时间片用完后，程序计数器会记录线程的运行代码位置，等待下次该线程重新获得cpu时间片，会从上次记录的位置开始运行。</p>

<h2 id="5方法区的前世今生">5、方法区的前世今生</h2>

<p>逻辑上属于堆，Java 1.8后物理上不属于堆，使用了元空间实现，不属于JVM</p>

<p>Method Area 方法区 是 Java虚拟机规范中定义的运行是数据区域之一，和堆（heap）一样可以在线程之间共享！</p>

<font color="red">天上飞的理念都会有落地的实现！</font>
<p><mark>元空间和永久代，都是对JVM规范中方法区的实现。</mark></p>

<p><strong>JDK1.7之前</strong></p>

<p>方法区的实现就是永久代</p>

<p>永久代：用于存储一些JVM加载类信息，常量，字符串、静态变量等等。。。。这些东西都会放到永久代中；</p>

<p>永久代大小空间是 有限的：如果满了就报异常 <font color="red">OutOfMemoryError：PermGen </font></p>

<p><strong>JDK1.8之后</strong></p>

<p>方法区在JVM（Hotspot）的实现就是元空间</p>

<p>彻底将永久代移除jvm（HotSpot），Java Heap 中或者 Metaspcace（别名 Native Heap）元空间；算出来的堆空间大小是不包含元空间的，所以说它物理上不属于堆</p>

<p>方法区存储：类信息，常量，字符串、静态变量、符号引用、方法代码。。。。。。</p>

<p><mark>元空间和永久代，都是对JVM规范中方法区的实现。</mark></p>

<p>元空间和永久代最大的区别：<mark>永久代在JVM中，受JVM限制，元空间并不在Java虚拟机中，使用的是本地内存！</mark></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># JVM参数，设置元空间大小</span>
<span class="nt">-XX</span>:MetasapceSize10m
</code></pre></div></div>

<p>如果元空间满了就报异常 <font color="red">OutOfMemoryError：MetaSpace</font></p>

<h2 id="6栈stack">6、栈Stack</h2>

<p>什么是栈？栈中存哪些东西？</p>

<p><strong>栈就是管理程序运行的</strong>，存储一些基本类型（8大基本类型）的值，对象的引用（引用变量），方法等….</p>

<h3 id="栈与对列">栈与对列</h3>

<p>程序 = 数据结构 + 算法（IT行业流传的术语）</p>

<p>程序 = 业务逻辑 + 框架（真的IT人员做的）</p>

<p>业务逻辑-&gt;框架原理 -&gt; 数据结构 -&gt; 算法</p>

<p>栈和队列都是基本的数据结构，队列：FIFO（First Input First  OutPut）</p>

<p><img src="/assets/images/2020/java/stack-and-queue.png" alt="" /></p>

<p><mark>吃多了垃就是队列，喝多了吐就是栈</mark></p>

<p><strong>程序的运行本质其实就是压栈的过程，栈空了，线程就结束了</strong></p>

<p><img src="/assets/images/2020/java/stack-main.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/stack-main-2.jpg" alt="" /></p>

<h3 id="栈是什么">栈是什么</h3>

<font color="red">**栈就是管理程序运行的**</font>
<p>，存储一些基本类型的值(局部变量)，对象的引用（引用变量），方法等….</p>

<p><img src="/assets/images/2020/java/stack.png" alt="" /></p>

<p><mark>栈的优势：</mark>存取速度比堆快！仅次于寄存器，栈的数据是不可以共享的，运行的线程独享该栈数据；</p>

<blockquote>
  <p>StackOverFlow 栈溢出</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">a</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// main  a  a  a   a a  a a a  a a  a  满</span>
    <span class="c1">// Exception in thread "main" java.lang.StackOverflowError</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="err">递归调用</span><span class="n">a</span><span class="o">()</span><span class="err">，最终导致栈溢出</span>
</code></pre></div></div>

<p>执行结果：</p>

<p><img src="/assets/images/2020/java/stackover-flow-error.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/stackover-flow-error-2.jpg" alt="" /></p>

<p>所以说，栈里面是一定不会存在垃圾回收的问题的，只要线程一旦结束，该栈就Over了。栈的生命周期和线程一致；</p>

<h3 id="栈原理">栈原理</h3>

<p>java栈的组成元素–<mark>栈帧</mark></p>

<p>例子：我们看的动画24帧，就是1秒有24个画面</p>

<p><img src="/assets/images/2020/java/stack-1.png" alt="" /></p>

<p>解释一下这幅图：先将F2压栈，再将F1压栈，F1的父帧是F2</p>

<p>栈（存什么）+ 堆 + 方法区(1.7就是永久代实现，1.8后就是元空间实现)的交互图，如下：</p>

<p><img src="/assets/images/2020/java/stack-2.png" alt="" /></p>

<p>我们的这个栈主要是 HotSpot JVM （指针）</p>

<p>假设你的公司用的 JVM 不是HotSpot，上面的图不是这样的</p>

<blockquote>
  <p>3种类型的JVM</p>
</blockquote>

<p><strong>问题：请你谈谈你认识几种 JVM？</strong> （3种）</p>

<ul>
  <li><strong>SUN 公司    HotSpot （掌握即可）</strong></li>
  <li>BEA  公司    JRockit</li>
  <li>IBM  公司    J9VM</li>
</ul>

<h2 id="7堆heap掌握">7、堆Heap（掌握）</h2>

<h3 id="java7之前">Java7之前</h3>

<p>Heap 堆，一个JVM实例中只存在一个堆，堆的内存大小是可以调节的。</p>

<p><strong>存储内容：类、方法、常量、保存了类型引用的真实信息；</strong></p>

<p><strong>分为三个部分：</strong></p>

<ul>
  <li>新生区：YoungGen（Eden-from-to）</li>
  <li>老年区：OldGen</li>
  <li>永久区：Perm</li>
</ul>

<p>堆内存在逻辑上分为三个部分：新生、老年、永久（JDK1.8以后，叫元空间）</p>

<p>物理上只有新生区、老年区；元空间在本地内存中，不在JVM中！</p>

<p><strong>GC 垃圾回收主要是在 新生区和老区，又分为 普通GC  和 Full GC(重GC)</strong>，如果堆满了，就会爆出 OutOfMemory；</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 打印jvm的垃圾回收详情信息</span>
java <span class="nt">-XX</span>:+PrintGCDetails <span class="nt">-version</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-print-gcdetails.jpg" alt="" /></p>

<h3 id="新生区eden-from-to">新生区（Eden-from-to）</h3>

<p>新生区 就是一个对象诞生、成长、消亡的地方！</p>

<p>新生区细分： Eden（伊甸园区）、Surival（幸存者区，细分为s0 幸存1区 和 幸存2区 s1，又叫做 from区 和 to区），所有的对象在Eden被 new 出来的，慢慢的当 Eden 满了，程序还需要创建对象的时候，就会触发一次轻量级GC；清理完一次垃圾之后，会将活下来的对象，会放入Surival(幸存者区)，……. 清理了 20次之后，出现了一些极其顽强的对象，有些对象突破了15次的垃圾回收！这时候就会将这个对象送入养老区！运行了几个月之后，养老区满了，就会触发一次 Full GC；假设项目1年后，整个空间彻彻底底的满了，突然有一天系统 OOM，排除OOM问题，或者重启；</p>

<p>Sun HotSpot JVM 虚拟机中，内存管理（分代管理机制：不同的区域使用不同的算法！）</p>

<p>Eden（伊甸园区）、Surival（幸存者区，细分 from区 和 to区）</p>

<p>99% 的对象在 Eden 都是临时对象；</p>

<h3 id="老年区">老年区</h3>

<p>15次都幸存下来的对象从新生区进入老年区，老年区满了之后，触发 Full GC</p>

<p>默认是15次，可以修改！</p>

<h3 id="永久区">永久区</h3>

<p><mark>放一些 JDK 自身携带的 Class、Interface的元数据；</mark></p>

<p>几乎不会被垃圾回收的；</p>

<font color="red">OutOfMemoryError：PermGen</font>
<p>在项目启动的时候永久代不够用了？例如引入加载大量的第三方包！</p>

<p>JDK1.6之前： 有永久代、常量池在方法区；</p>

<p>JDK1.7：有永久代、但是开始尝试去永久代，常量池在堆中；</p>

<p>JDK1.8 之后：永久代没有了，取而代之的是元空间；常量池在元空间中；</p>

<p>闲聊：方法区和堆一样，是共享的区域，是JVM 规范中的一个逻辑的部分，但是记住它的别名 <mark>非堆</mark></p>

<p><mark>元空间和永久代，都是对JVM规范中方法区的实现。</mark></p>

<p><mark>元空间：它是本地内存！</mark></p>

<p>元空间满了也会溢出：<font color="red">OutOfMemoryError：MetaSpace</font></p>

<h2 id="8jvm调优参数">8、JVM调优参数</h2>

<p>三种参数类型：标配参数、X参数，XX参数</p>

<h3 id="标配参数x与xx参数">标配参数、X与XX参数</h3>

<p>在各种版本之间都很稳定，很少有变化</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-version</span>
java <span class="nt">-help</span>
java <span class="nt">-showversion</span>
<span class="c"># 查看运行的java进程</span>
xjwdeMacBook:~ xjw<span class="nv">$ </span>jps <span class="nt">-l</span>
614 
681 org.jetbrains.idea.maven.server.RemoteMavenServer
683 org.jetbrains.jps.cmdline.Launcher
684 com.coding.oom.Demo04
685 sun.tools.jps.Jps
</code></pre></div></div>

<blockquote>
  <p>X与XX参数</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-X</span> <span class="nt">-help</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-x-help.jpg" alt="" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-Xint</span>          <span class="c"># 解释执行</span>
<span class="nt">-Xcomp</span>         <span class="c"># 第一次使用就编译成本地的代码</span>
<span class="nt">-Xmixed</span>        <span class="c"># 混合模式（Java默认）</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-mixed-int-comp-mod.png" alt="" /></p>

<blockquote>
  <p>XX参数布尔型</p>
</blockquote>

<p>-XX: + 或者 - 某个属性值， + 代表开启某个功能，- 表示关闭了某个功能！；</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello,World"</span><span class="o">);</span>
       <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="no">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>运行程序，通过<mark>jps</mark> 查看运行的java进程</p>

<p><img src="/assets/images/2020/java/jps-l.jpg" alt="" /></p>

<p>通过<mark>jinfo -flag </mark> 功能  线程ID 查看运行中的java 程序，它的某个参数是否开启</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看是否开启打印gc详情信息</span>
xjwdeMacBook:~ xjw<span class="nv">$ </span>jinfo <span class="nt">-flag</span> PrintGCDetails 684
<span class="nt">-XX</span>:-PrintGCDetails  <span class="c"># - 表示关闭了该功能</span>
</code></pre></div></div>

<p>开启打印gc详情</p>

<p><img src="/assets/images/2020/java/printgcdetails.jpg" alt="" /></p>

<p>重新运行程序，<mark>jinfo</mark>查看是否开启参数打印gc信息， + 代表开启某个功能</p>

<p><img src="/assets/images/2020/java/printgcdetails-2.jpg" alt="" /></p>

<blockquote>
  <p>XX参数之key = value型；</p>
</blockquote>

<p>1、查看元空间大小，是key=value型的</p>

<p><img src="/assets/images/2020/java/jinfo-flag-metaspace-size.jpg" alt="" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 修改元空间大小</span>
<span class="nt">-XX</span>:MetaspaceSize<span class="o">=</span>128m
</code></pre></div></div>

<p><img src="/assets/images/2020/java/vm-options-metaspace-size.jpg" alt="" /></p>

<p>2、查看进入养老区的存活年限（默认是15），该参数控制对象在新生代需要经历多少次GC后晋升到老年代的最大阀值，在JVM中用4个bit（位）存储（放在对象头中），所以最大值是15</p>

<p><img src="/assets/images/2020/java/jinfo-flag-max-tenuring-threshold.jpg" alt="" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-XX</span>:MaxTenuringThreshold<span class="o">=</span>15
</code></pre></div></div>

<p><img src="/assets/images/2020/java/vm-options-max-tenuring-threshold.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/vm-options-max-tenuring-threshold-2.jpg" alt="" /></p>

<h3 id="默认值">默认值</h3>

<p><strong>查看所有默认值</strong></p>

<p><mark>jinfo -flags</mark></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jinfo <span class="nt">-flags</span> 3304 <span class="c"># 3304是使用jps -l 查出来运行的java程序ID</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/vm-options-metaspace-size.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/jinfo.png" alt="" /></p>

<p>查看到初始的堆内存大小-XX:Initi，最大的堆内存大小等信息，-XX:+UseParallelGC，默认使用并行垃圾回收</p>

<p>Command line: 我们通过idea运行程序是给它传了个jvm 参数 -XX:MetaspaceSize=128m，</p>

<p><mark></mark></p>

<p>经典面试题：-Xms, -Xmx，怎么解释呢？考察你到底研究过没有！</p>

<p>1、-Xms初始堆的大小，等价：<mark>-XX:InitialHeapSize</mark>，一般是物理内存的 1/64</p>

<p>2、-Xmx最大堆的大小 ，等价：<mark>-XX:MaxHeapSize</mark>，一般是物理内存的 1/4</p>

<p>最常用的东西都是有语法糖的！</p>

<p><strong>初始默认值</strong></p>

<p>初始的默认值到底有多少？</p>

<blockquote>
  <p>java -XX:+PrintFlagsInitial</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 java 环境初始默认值；这里面只要显示的值，我们都可以手动赋值，不建议修改，了解即可！</span>
java <span class="nt">-XX</span>:+PrintFlagsInitial
</code></pre></div></div>

<p><img src="/assets/images/2020/java/xx-printflags-initial.png" alt="" /></p>

<p><mark>=</mark> 默认值</p>

<p><mark>:=</mark>  就是被修改过的值</p>

<blockquote>
  <p>java -XX:+PrintFlagsFinal -Xss128k GCDemo</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GCDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello,World"</span><span class="o">);</span>
       <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="no">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用java命令行执行程序</p>

<p><img src="/assets/images/2020/java/java-gcdemo.jpg" alt="" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看被修改过的值！启动程序的时候判断，修改线程栈大小为128k</span>
java <span class="nt">-XX</span>:+PrintFlagsFinal <span class="nt">-Xss128k</span> GCDemo  
</code></pre></div></div>

<p><img src="/assets/images/2020/java/java-gcdemo-2.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/java-gcdemo-3.jpg" alt="" /></p>

<blockquote>
  <p>java -XX:+PrintCommandLineFlags</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 打印出用户手动选项的 XX 选项</span>
java <span class="nt">-XX</span>:+PrintCommandLineFlags <span class="nt">-version</span>  
</code></pre></div></div>

<h3 id="常用参数">常用参数</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-XX</span>:+HeapDumpOnOutOfMemoryError <span class="c"># 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</span>
<span class="nt">-Xms2g</span>   <span class="c"># 初始堆内存大小2g，一般是物理内存的 1/64</span>
<span class="nt">-Xmx2g</span>   <span class="c"># 最大堆内存大小2g，一般是物理内存的 1/4</span>
<span class="nt">-Xss200m</span>  <span class="c"># 线程栈大小设置，默认 512k~1024k</span>
<span class="nt">-Xmn</span>  <span class="c"># 设置新生区的大小，一般不用动！</span>
<span class="nt">-XX</span>:MetaspsaceSize<span class="o">=</span>128m  <span class="c"># 设置元空间的大小，这个在本地内存中！OOM</span>
<span class="nt">-XX</span>:MaxMetaspaceSize<span class="o">=</span>128m <span class="c"># 最大的元空间大小</span>
<span class="nt">-XX</span>:+PrintGCDetails <span class="c"># 打印垃圾回收的详细信息</span>
<span class="nt">-XX</span>:+TraceClassLoading <span class="c"># 用于追踪类的加载信息并打印出来</span>
<span class="nt">-XX</span>:SurvivorRatio<span class="o">=</span>8 <span class="c"># 设置新生代中的 s0/s1 空间的占比，默认就是8，s0又叫from区，s1又叫to区</span>
	uintx SurvivorRatio  <span class="o">=</span> 8 那么新生代中 Eden：s0：s1 <span class="o">=</span> 8:1:1
	uintx SurvivorRatio  <span class="o">=</span> 4 那么新生代中 Eden：s0：s1 <span class="o">=</span> 4:1:1
<span class="nt">-XX</span>:NewRatio<span class="o">=</span>2    <span class="c"># 设置新生代(Eden:Surival(from:to))与老年代的占比：</span>
	NewRatio  <span class="o">=</span> 2   新生代1，老年代是2，默认新生代是整个堆的 1/3<span class="p">;</span>  1:2
	NewRatio  <span class="o">=</span> 4   新生代1，老年代是4，默认新生代是整个堆的 1/5<span class="p">;</span>  1:4
<span class="nt">-XX</span>:MaxTenuringThreshold<span class="o">=</span>15 <span class="c"># 对象从新生代进入老年代的存活阈值（默认15）15次GC后对象还存在新生代，那么下次GC就会进入老年代</span>
<span class="nt">-XX</span>:+UseParNewGC <span class="c"># 指定使用 ParNew + Serial Old 垃圾回收器组合；</span>
<span class="nt">-XX</span>:+UseParallelOldGC <span class="c"># 指定使用 ParNew + ParNew Old 垃圾回收器组合；</span>
<span class="nt">-XX</span>:+UseConcMarkSweepGC <span class="c"># 指定使用 CMS + Serial Old 垃圾回收器组合；</span>
<span class="nt">-XX</span>:+PrintGCDetails <span class="c"># 打印 gc 详细信息</span>
<span class="nt">-XX</span>:+TraceClassLoading <span class="c"># 用于追踪类的加载信息并打印出来</span>
<span class="nt">-XX</span>:MaxDirectMemorySize<span class="o">=</span>128m <span class="c"># 最大的基础缓冲区大小</span>

<span class="nt">-Xms8m</span> <span class="nt">-Xmx8m</span> <span class="nt">-XX</span>:+PrintGCDetails
初始堆内存大小8m,最大堆内存大小8m,打印gc信息
</code></pre></div></div>

<p>使用java -XX:+PrintFlagsInitial 查看参数默认值</p>

<p><img src="/assets/images/2020/java/surivivor-ratio.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/newratio.jpg" alt="" /></p>

<h3 id="调优实例参考">调优实例参考</h3>

<blockquote>
  <p>测试堆内存=新生区+老年区内存</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">coding</span><span class="o">.</span><span class="na">oom</span><span class="o">;</span>

<span class="cm">/**
 * 默认情况：
 * maxMemory : 1808.0MB （虚拟机试图使用的最大的内存量  一般是物理内存的 1/4）
 * totalMemory : 123.0MB （虚拟机试图默认的内存总量 一般是物理内存的 1/64）
 */</span>
<span class="c1">// 我们可以自定堆内存的总量</span>
<span class="c1">// -XX:+PrintGCDetails; // 输出详细的垃圾回收信息</span>
<span class="c1">// -Xmx: 最大分配内存； 1/4</span>
<span class="c1">// -Xms: 初始分配的内存大小； 1/64</span>

<span class="c1">// -Xmx1024m -Xms1024m -XX:+PrintGCDetails</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo01</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 获取堆内存的初始大小和最大大小</span>
    <span class="kt">long</span> <span class="n">maxMemory</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">maxMemory</span><span class="o">();</span>
    <span class="kt">long</span> <span class="n">totalMemory</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">totalMemory</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"maxMemory="</span><span class="o">+</span><span class="n">maxMemory</span><span class="o">+</span><span class="s">"(字节)、"</span><span class="o">+(</span><span class="n">maxMemory</span><span class="o">/</span><span class="mi">1024</span><span class="o">/(</span><span class="kt">double</span><span class="o">)</span><span class="mi">1024</span><span class="o">)+</span><span class="s">"MB"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"totalMemory="</span><span class="o">+</span><span class="n">totalMemory</span><span class="o">+</span><span class="s">"(字节)、"</span><span class="o">+(</span><span class="n">totalMemory</span><span class="o">/</span><span class="mi">1024</span><span class="o">/(</span><span class="kt">double</span><span class="o">)</span><span class="mi">1024</span><span class="o">)+</span><span class="s">"MB"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/oom-vm-options.jpg" alt="" /></p>

<p>执行结果：</p>

<p><img src="/assets/images/2020/java/young-old-gen.png" alt="" /></p>

<p>可以看到堆的总内存大小 = PSYoungGen + ParOldGen</p>

<blockquote>
  <p>提升性能15%</p>
</blockquote>

<p>转载来源地址：https://zhenbianshu.github.io</p>

<p>项目的基本情况：项目是一个高 QPS 压力的 web 服务，单机 QPS 一直维持在 1.5K 以上，由于旧机器的”拖累”，配置的堆大小是 8G，其中 young 区是 4G，old区就是8-4G，垃圾回收器用的是 parNew + CMS。</p>

<p>使用 <code class="highlighter-rouge">jstat -gcutil pid 1000</code> 每隔一秒打印一次 gc 统计信息。</p>

<p><img src="\assets\images\2020\java\jvm-debug-1.jpg" alt="" /></p>

<p>可以看到，单次 gc 平均耗时是 60ms 左右，还算可以接受，但 YGC 非常频繁，基本上每秒一次，有的时候还会一秒两次，在一秒两次的时候，服务对业务响应时长的压力就会变得很大。</p>

<p>接着查看 gc log，打印 gc log 需要在 JVM 启动参数里添加以下参数：</p>

<ul>
  <li><code class="highlighter-rouge">-XX:+PrintGCDateStamps</code>：打印 gc 发生的时间戳。</li>
  <li><code class="highlighter-rouge">-XX:+PrintTenuringDistribution</code>：打印 gc 发生时的分代信息。</li>
  <li><code class="highlighter-rouge">-XX:+PrintGCApplicationStoppedTime</code>：打印 gc 停顿时长</li>
  <li><code class="highlighter-rouge">-XX:+PrintGCApplicationConcurrentTime</code>：打印 gc 间隔的服务运行时长</li>
  <li><code class="highlighter-rouge">-XX:+PrintGCDetails</code>：打印 gc 详情，包括 gc 前/内存等。</li>
  <li><code class="highlighter-rouge">-Xloggc:../gclogs/gc.log.date</code>：指定 gc log 的路径</li>
</ul>

<p><img src="\assets\images\2020\java\jvm-debug-gc-log.jpg" alt="" /></p>

<p>单次 GC 方面并不能直接看出问题，但可以看到 gc 前有很多次 18ms 左右的停顿。</p>

<p><strong>YGC频繁</strong></p>

<p>轻GC频繁，借助可视化工具分析，把gc log 上传到gceasy网站 <a href="https://gceasy.io/">https://gceasy.io/</a>，它可以帮助我们生成各个维度的图表帮助分析。</p>

<p>查看 gceasy 生成的报告，发现我们服务的 gc 吞吐量是 95%，它指的是 JVM 运行业务代码的时长占 JVM 总运行时长的比例，这个比例确实有些低了，运行 100 分钟就有 5 分钟在执行 gc。幸好这些 GC 中绝大多数都是 YGC，单次时长可控且分布平均，这使得我们服务还能平稳运行。</p>

<p>解决这个问题</p>

<ul>
  <li>
    <p>减少对象的创建，不是一时半会儿能解决的，需要查找代码里可能有问题的点，分步优化</p>
  </li>
  <li>
    <p>增大 young 区，虽然改一下配置就行，但以我们对 GC 最直观的印象来说，增大 young 区，YGC 的时长也会迅速增大，要清除的垃圾对象多了，所以需要更多的GC时间。</p>

    <p>其实这点不必太过担心，我们知道 YGC 的耗时是由 <code class="highlighter-rouge">GC 标记 + GC 复制</code> 组成的，GC复制用在新生区，GC标记用在老年区。相对于 GC 复制，GC 标记是非常快的。而 young 区内大多数对象的生命周期都非常短，如果将 young 区增大一倍，GC 标记的时长会提升一倍，但到 GC 发生时被标记的对象大部分已经死亡， GC 复制的时长肯定不会提升一倍，所以我们可以放心增大 young 区大小。</p>
  </li>
</ul>

<p>由于低内存旧机器都被换掉了，我把堆大小调整到了 12G，young 区保留为 8G。</p>

<p><strong>分代MaxTenuringThreshold年龄调整</strong></p>

<p>除了 GC 太频繁之外，GC 后各分代的平均大小也需要调整。</p>

<p><img src="\assets\images\2020\java\jvm-debug-2.jpg" alt="" /></p>

<p>我们知道 GC 的提升机制，每次 GC 后，JVM 存活代数大于 <code class="highlighter-rouge">MaxTenuringThreshold</code> 的对象提升到老年代。当然，JVM 还有动态年龄计算的规则：按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值，但看各代总的内存大小，是达不到 survivor 区的一半的。如下图：</p>

<p><img src="\assets\images\2020\java\jvm-debug-3.jpg" alt="" /></p>

<p>所以这十五个分代的对象会一直在两个 survivor 区之间（from区和to区）来回复制，每ygc一次就会触发存活对象从eden区和from区复制到to区，同时对象的分代年龄+1。再观察各分代的平均大小，可以看到，四代以上的对象已经有一半都会保留到老年区了，所以将这些对象直接提升到老年代，以减少对象在两个 survivor 区之间复制的性能开销。</p>

<p>所以我把 MaxTenuringThreshold 的值调整为 4，将存活超过四代的对象直接提升到老年代。</p>

<p><strong>偏向锁停顿</strong></p>

<p>还有一个问题是 gc log 里有很多 18ms 左右的停顿，有时候连续有十多条，虽然每次停顿时长不长，但连续多次累积的时间也非常可观。</p>

<p>1.8 之后 JVM 对锁进行了优化，添加了偏向锁的概念，避免了很多不必要的加锁操作，但偏向锁一旦遇到锁竞争，取消锁需要进入 <code class="highlighter-rouge">safe point</code>，导致 STW。</p>

<p>解决方式很简单，JVM 启动参数里添加 <code class="highlighter-rouge">-XX:-UseBiasedLocking</code>  使用偏向锁即可。</p>

<p><strong>结果</strong></p>

<p>调整完 JVM 参数后先是对服务进行压测，发现性能确实有提升，也没有发生严重的 GC 问题，之后再把调整好的配置放到线上机器进行灰度，同时收集 gc log，上传到<a href="https://gceasy.io">gceasy</a> 再次进行分析</p>

<p>由于 young 区大小翻倍了，所以 YGC 的频率减半了，GC 的吞量提升到了 97.75%。平均 GC 时长略有上升，从 60ms 左右提升到了 66ms，还是挺符合预期的。</p>

<p>由于 CMS 在进行 GC 时也会清理 young 区，CMS 的时长也受到了影响，CMS 的最终标记和并发清理阶段耗时增加了，也比较正常。</p>

<h2 id="9dump内存快照">9、Dump内存快照</h2>

<h3 id="jvm分析常用命令">Jvm分析常用命令</h3>

<p>点进Java的bin目录，内置工具命令你认识多少</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javac  <span class="c"># 编译.java源码文件为.class字节码文件</span>
java <span class="nt">-jar</span>  xxx.jar <span class="c"># 可带配置参数或者JVM参数启动java程序</span>
java <span class="nt">-jar</span> test3.jar <span class="nt">--spring</span>.config.location<span class="o">=</span>application.properties
<span class="c"># 动态参数启动</span>
java <span class="nt">-jar</span> <span class="nt">-Dserver</span>.port<span class="o">=</span>8081 sentinel-dashboard-1.7.0.jar

jps <span class="nt">-l</span> <span class="c"># 查看运行的java进程id</span>
javap <span class="nt">-c</span> Vdemo02.class  <span class="c"># 对字节码文件进行反汇编</span>

<span class="c"># 常用的就是结合-dump参数导出内存信息文件，使用MAT 或者 jprofile 分析dump文件</span>
jmap<span class="o">(</span>java memory map<span class="o">)</span> java内存映像工具 
<span class="c"># 命令格式 </span>
jmap <span class="nt">-dump</span>:live,format<span class="o">=</span>b,file<span class="o">=</span>文件路径/文件名  pid
<span class="c"># 例子：</span>
<span class="o">&gt;</span> jps 
58837 GCTest 
58838 Jps
<span class="o">&gt;</span>jmap <span class="nt">-dump</span>:live,format<span class="o">=</span>b,file<span class="o">=</span>dmp.hprof 58837

<span class="c"># 分析java进程ID或core file或远程调试服务的Java堆栈信息</span>
jstack java进程id

<span class="c"># 一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM</span>
<span class="c"># 建立java进程的连接后，可以查看内存、CPU、线程等使用情况</span>
jconsole 
</code></pre></div></div>

<p>请你说说在在工作如何排查OOM？我是通过Dump内存快照查看的，可以使用Jconsole和Jprofile工具</p>

<p>在java程序运行的时候，想测试运行的情况！</p>

<p>使用一些工具来查看；</p>

<p>1、Jconsole</p>

<p>2、idea debug</p>

<p>3、Eclipse（MAT插件）</p>

<p>4、IDEA（Jprofiler插件）</p>

<h3 id="jconsole">Jconsole</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo05</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"start"</span><span class="o">);</span>
		<span class="c1">// 睡眠到死</span>
		<span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>启动程序，进入jdk安装目录，找到Jconsole</p>

<p><img src="/assets/images/2020/java/jconsole.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/jconsole-2.jpg" alt="" /></p>

<p>连接后</p>

<p><img src="/assets/images/2020/java/jconsole-3.jpg" alt="" /></p>

<p>线程在干什么</p>

<p><img src="/assets/images/2020/java/jconsole-4.jpg" alt="" /></p>

<p>加载的类</p>

<p><img src="/assets/images/2020/java/jconsole-5.jpg" alt="" /></p>

<p>概要</p>

<p><img src="/assets/images/2020/java/jconsole-6.jpg" alt="" /></p>

<h3 id="java-visualvm">Java VisualVM</h3>

<h3 id="jprofiler">Jprofiler</h3>

<p>一款性能瓶颈分析插件</p>

<p>1、IDEA安装 JProfiler 插件</p>

<p><img src="/assets/images/2020/java/idea-install-plugin-jprofiler.png" alt="" /></p>

<p>2、window上安装 JProfiler （无脑下一步即可：注意路径中不能有中文和空格，否则报错 ）</p>

<p>我使用的是Mac 笔记本,在xclient.info搜索该软件</p>

<p><img src="/assets/images/2020/java/jprofiler.jpg" alt="" /></p>

<p>注册码分享</p>

<p>Name：<strong>rjsos</strong></p>

<p>Company：<strong>rjsos</strong></p>

<p>License key：<strong>A-J11-Everyone#admin-3v7hg353d6idd5#9b4</strong></p>

<p>3、激活</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 注册码仅供大家参考</span>
L-Larry_Lau@163.com#23874-hrwpdp1sh1wrn#0620
L-Larry_Lau@163.com#36573-fdkscp15axjj6#25257
L-Larry_Lau@163.com#5481-ucjn4a16rvd98#6038
L-Larry_Lau@163.com#99016-hli5ay1ylizjj#27215
L-Larry_Lau@163.com#40775-3wle0g1uin5c1#0674
</code></pre></div></div>

<p>4、在IDEA 中绑定 JProfiler</p>

<p><img src="/assets/images/2020/java/idea-bind-jprofiler.png" alt="" /></p>

<p><img src="/assets/images/2020/java/idea-jprofiler.jpg" alt="" /></p>

<blockquote>
  <p>Jprofile的快速体验</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">coding</span><span class="o">.</span><span class="na">oom</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="c1">// -Xmx10m -Xms10m -XX:+HeapDumpOnOutOfMemoryError</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo03</span> <span class="o">{</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">];</span> <span class="c1">// 1M</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="c1">// 泛型：约束！</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Demo03</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Demo03</span><span class="o">&gt;();</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// Error 与 Exception是平级的关系，所以永远都不会捕获到Exception,要使用共同的父类Throwable，</span>
            <span class="c1">// 不停的往里面加对象</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Demo03</span><span class="o">());</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Throwable 或者 Error</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"count="</span><span class="o">+</span><span class="n">count</span><span class="o">);</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/java/throwable-error-exception.jpg" alt="" /></p>

<p><img src="/assets/images/2020/java/oom-10m.jpg" alt="" /></p>

<p>执行结果</p>

<p><img src="/assets/images/2020/java/oom-10m-2.jpg" alt="" /></p>

<p>7次就堆内存爆满了</p>

<p>怎么分析找到报错的代码？加上JVM参数 -XX:+HeapDumpOnOutOfMemoryError</p>

<p><img src="/assets/images/2020/java/oom-10m-4.jpg" alt="" /></p>

<p>执行结果：</p>

<p><img src="/assets/images/2020/java/oom-10m-3.jpg" alt="" /></p>

<p>可以发现我们Dump出一个内存快照文件，它被放在了当前项目的目录下</p>

<p><img src="/assets/images/2020/java/oom-10m-jprofile.jpg" alt="" /></p>

<p>我们使用Jprofile打开它，这是离线分析模式</p>

<p><img src="/assets/images/2020/java/oom-10m-jprofile-2.jpg" alt="" /></p>

<p>点击大对象，发现很明显有一个list对象有问题</p>

<p><img src="/assets/images/2020/java/oom-10m-jprofile-3.jpg" alt="" /></p>

<p>展开该对象，精准定位到问题的代码行</p>

<p><img src="/assets/images/2020/java/oom-10m-jprofile-4.jpg" alt="" /></p>

<blockquote>
  <p>在Idea直接点击jprofile运行</p>
</blockquote>

<p><img src="/assets/images/2020/java/idea-profile-demo03.jpg" alt="" /></p>

<p>点击右上角的停止按钮停止jprofile运行程序</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo04</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"sdsdfs"</span><span class="o">);</span>
        <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="no">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用jprofile 运行，可以实时监控程序</p>

<p><img src="/assets/images/2020/java/oom-10m-jprofile-5.jpg" alt="" /></p>

<p>分析dump出来的快照，查看异常对象；分析定位到具体的类和代码问题！dump出来的文件一般都比较大</p>



            <div>
   <!-- <p align="center">
     	  
         <img src="/assets/images/keeppuresmile.jpg" >
         <br/>
         微信扫描二维码，关注一个有故事的程序员
        

   </p>
   <p align="center" style="margin-top: 15px; font-size: 11px;color: #cc0000;">
       <strong>（转载本站文章请注明作者和出处 <a href="http://www.ityouknow.com">纯洁的微笑-ityouknow</a>）</strong>
   </p>
   <p align="center" style="margin-top: 15px; font-size: 16px;color: #337ab7;">
       <strong><a href="http://www.justdojava.com/" target="_blank">点击了解 ：Java 技术人的网站</a></strong>
   </p> -->
</div>

            <!-- Comments -->
            <div class="comment">
             

  

  
        <div id="gitalk-container"></div>
        <script src="/assets/js/gitalk.min.js"></script>
        <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> -->
        <script>
        var gitalk = new Gitalk({
            id: '/icoding-edu/2020/03/08/icoding-note-006.html',
            clientID: '6cd8ad4d1cf1d1e6ad95',
            clientSecret: 'c4ce22a25efe50bfd60da67c990b534bc99a6424',
            repo: 'aikomj.github.io',
            owner: 'aikomj',
            admin: ['aikomj'],
            labels: ['gitalk'],
            perPage: 50,
        })
        gitalk.render('gitalk-container')
        </script>
  


            </div>
        </div>

        <div class="col-md-3">
            <h3>Post Directory</h3>
<div id="post-directory-module">
<section class="post-directory">
    <!-- Links that trigger the jumping -->
    <!-- Added by javascript below -->
    <dl></dl>
</section>
</div>

<script type="text/javascript">

    $(document).ready(function(){
        $( "article h2" ).each(function( index ) {
            $(".post-directory dl").append("<dt><a class=\"jumper\" hre=#" +
                    $(this).attr("id")
                    + ">"
                    + $(this).text()
                    + "</a></dt>");

            var children = $(this).nextUntil("h2", "h3")

            children.each(function( index ) {
                $(".post-directory dl").append("<dd><a class=\"jumper\" hre=#" +
                        $(this).attr("id")
                        + ">"
                        + "&nbsp;&nbsp;- " + $(this).text()
                        + "</a></dd>");
            });
        });

        var fixmeTop = $('#post-directory-module').offset().top - 100;       // get initial position of the element

        $(window).scroll(function() {                  // assign scroll event listener

            var currentScroll = $(window).scrollTop(); // get current position

            if (currentScroll >= fixmeTop) {           // apply position: fixed if you
                $('#post-directory-module').css({      // scroll to that element or below it
                    top: '100px',
                    position: 'fixed',
                    width: 'inherit'
                });
            } else {                                   // apply position: static
                $('#post-directory-module').css({      // if you scroll above it
                    position: 'inherit',
                    width: 'inherit'
                });
            }

        });

        $("a.jumper").on("click", function( e ) {

            e.preventDefault();

            $("body, html").animate({
                scrollTop: ($( $(this).attr('hre') ).offset().top - 100)
            }, 600);

        });
    });

</script>
        </div>
        

    </div>
     <!--<div class="asb-post-01">-->
        <!--<div class="mask"></div>-->
            <!--<div class="info">-->
                <!--<div>扫码关注公众号：<span style="color: #E9405A; font-weight: bold;">纯洁的微笑</span></div>-->
            <!--<div>-->
            <!--<span>发送 </span><span class="token" style="color: #e9415a; font-weight: bold; font-size: 17px; margin-bottom: 45px;">290992</span>-->
            <!--<div>-->
                <!--即可<span style="color: #e9415a; font-weight: bold;">立即永久</span>解锁本站全部文章-->
            <!--</div>-->
            <!--<img class="code-img" style="width: 300px;display:unset" src="/assets/images/keeppuresmile.jpg">-->
        <!--</div>-->
    <!--</div>-->
</article>

        </div>

    
<footer class="container">
    <div class="site-footer">
       <!--  <div class="site-footer-icons">
            <a target="_blank" href="https://www.zhihu.com/people/ityouknow">
               知乎
            </a>
            <a target="_blank" href="http://weibo.com/ityouknow">
               微博
            </a>
            <a target="_blank" href="https://github.com/ityouknow">
                GitHub
            </a>
        </div> -->
        <!-- <div class="card text-center">
            <ul class="list-inline" style="margin-left: 0;">
               <li>
                <a target="_blank" href="https://github.com/ityouknow">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a target="_blank" href="https://www.zhihu.com/people/ityouknow">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa  fa-stack-1x fa-inverse">知</i>
                  </span>
                </a>
              </li>
                  <li>
                <a target="_blank" href="https://weibo.com/ityouknow">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          </ul>
        </div> -->
        <div class="site-footer-links mobile-hidden">
            
        </div>
        <div class="scrolltop">
            <a href="javascript:window.scrollTo(0,0)" >TOP</a>
        </div>
        <div class="rss">
            <a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a>
            Power by <a href="https://github.com/DONGChuan/Yummy-Jekyll">Yummy Jekyll</a>
        </div>
    </div>
    <!-- Third-Party JS -->
    <script type="text/javascript" src="/bower_components/geopattern/js/geopattern.min.js"></script>
    <!-- My JS -->
    <script type="text/javascript" src="/assets/js/script.js"></script>
    
    
     <!-- Cnzz Analytics -->
       <div style="display:none">
         <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260945749'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1260945749' type='text/javascript'%3E%3C/script%3E"));</script>
       </div>
     <!-- Cnzz Analytics -->
</footer>


    </body>

</html>
