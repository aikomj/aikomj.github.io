<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Favicon Icon -->
    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico">

    <title> 飞天班第36节：Redis（3） - 大伟的博客 </title>
    <meta name="keywords" content="redis">
    <meta name="description"
          content="Redis持久化 rdb 和 aof，Redis事务的概念和测试乐观锁，消息发布订阅，（重点)主从复制 + 哨兵模式">

    <link rel="canonical" href="http://47.113.95.179/jk-blog/icoding-edu/2020/05/17/icoding-note-036.html">
    <link rel="alternate" type="application/rss+xml" title="大伟,专注Spring Boot,Spring Cloud,Docker,Java后端技术" href="http://47.113.95.179/jk-blog/feed.xml">

    <!-- Third-Party CSS -->
    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/bower_components/octicons/octicons/octicons.css">
    <link rel="stylesheet" href="/bower_components/hover/css/hover-min.css">
    <link rel="stylesheet" href="/bower_components/primer-markdown/dist/user-content.min.css">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" href="/assets/css/gitalk.css">
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->

    

    <!-- My CSS -->
    <link rel="stylesheet" href="/assets/css/common.css">

    <!-- CSS set in page -->
    

    <!-- CSS set in layout -->
    
    <link rel="stylesheet" href="/assets/css/sidebar-post-nav.css">
    

    <!--<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">-->

    <script type="text/javascript" src="/bower_components/jquery/dist/jquery.min.js"></script>
    <script type="text/javascript" src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/lock.js"></script>
</head>


    <body>

    <header class="site-header">
    <div class="site-header-topbar">
        <div class="container">
            <div class="topbar-menu">
                
                <div class="item">
                    <a href="/archives.html"
                       target="_self"
                       title="Archives">
                        Archives
                    </a>
                </div>
                
                <div class="item">
                    <a href="/linux.html"
                       target="_self"
                       title="Linux">
                        Linux
                    </a>
                </div>
                
                <div class="item">
                    <a href="/mysql.html"
                       target="_self"
                       title="Mysql">
                        Mysql
                    </a>
                </div>
                
                <div class="item">
                    <a href="/mongodb.html"
                       target="_self"
                       title="MongoB">
                        MongoB
                    </a>
                </div>
                
                <div class="item">
                    <a href="/mq.html"
                       target="_self"
                       title="MQ">
                        MQ
                    </a>
                </div>
                
                <div class="item">
                    <a href="/fastdfs.html"
                       target="_self"
                       title="FastDFS">
                        FastDFS
                    </a>
                </div>
                
                <div class="item">
                    <a href="/redis.html"
                       target="_self"
                       title="Redis">
                        Redis
                    </a>
                </div>
                
                <div class="item">
                    <a href="/elasticsearch.html"
                       target="_self"
                       title="ES">
                        ES
                    </a>
                </div>
                
                <div class="item">
                    <a href="/docker.html"
                       target="_self"
                       title="Docker">
                        Docker
                    </a>
                </div>
                
                <div class="item">
                    <a href="/k8s.html"
                       target="_self"
                       title="K8s">
                        K8s
                    </a>
                </div>
                
                <div class="item">
                    <a href="/architect.html"
                       target="_self"
                       title="架构师">
                        架构师
                    </a>
                </div>
                
                <div class="item">
                    <a href="/gitee.html"
                       target="_self"
                       title="开源项目">
                        开源项目
                    </a>
                </div>
                
                <div class="item">
                    <a href="/tool.html"
                       target="_self"
                       title="工具">
                        工具
                    </a>
                </div>
                
                <div class="item">
                    <a href="/life.html"
                       target="_self"
                       title="生活">
                        生活
                    </a>
                </div>
                
                <div class="item">
                    <a href="/say.html"
                       target="_self"
                       title="说说">
                        说说
                    </a>
                </div>
                
                <div class="item">
                    <a href="/link.html"
                       target="_self"
                       title="友链">
                        友链
                    </a>
                </div>
                
            </div>
        </div>
    </div>
    <div class="container">
        <a id="site-header-brand" href="/" title="大展宏兔">
            <!--<span class="octicon octicon-mark-github"></span>-->
            <img class="logo" src="/assets/images/favicon.jpeg">
            大展宏兔
        </a>
        <nav class="site-header-nav" role="navigation">
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/"
                   target=""
                   title="Home">
                    Home
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href=""
                   target=""
                   title="Icoding">
                    Icoding
                </a>
                
                <ul class="submenu">
                    
                    <li><a href="/icoding-edu.html" 
                           target="_self"
                     >飞天班笔记</a></li>
                    
                    <li><a href="/icoding-gavin.html" 
                           target="_self"
                     >黄埔班笔记</a></li>
                    
                    <li><a href="/icoding-allen.html" 
                           target="_self"
                     >源码分析</a></li>
                    
                    <li><a href="https://www.icodingedu.com/" 
                           target="_blank"
                     >艾编程官网</a></li>
                    
                    <li><a href="https://leetcode-cn.com/problemset/all/" 
                           target="_blank"
                     >力扣刷题</a></li>
                    
                </ul>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href=""
                   target=""
                   title="Java">
                    Java
                </a>
                
                <ul class="submenu">
                    
                    <li><a href="/java-base.html" 
                           target="_self"
                     >Java基础</a></li>
                    
                    <li><a href="/java-concurrent.html" 
                           target="_self"
                     >Java并发</a></li>
                    
                    <li><a href="/design-mode.html" 
                           target="_self"
                     >设计模式</a></li>
                    
                    <li><a href="http://www.justdojava.com" 
                           target="_blank"
                     >Java 极客技术</a></li>
                    
                </ul>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/spring.html"
                   target="_self"
                   title="Spring">
                    Spring
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/spring-boot.html"
                   target="_self"
                   title="Spring Boot">
                    Spring Boot
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/spring-cloud.html"
                   target="_self"
                   title="Spring Cloud">
                    Spring Cloud
                </a>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href=""
                   target=""
                   title="Go全栈">
                    Go全栈
                </a>
                
                <ul class="submenu">
                    
                    <li><a href="/go-base.html" 
                           target="_self"
                     >Go语言基础</a></li>
                    
                    <li><a href="/go-web.html" 
                           target="_self"
                     >Web开发</a></li>
                    
                    <li><a href="/go-middleware.html" 
                           target="_self"
                     >中间件</a></li>
                    
                </ul>
                
            </div>
            
            <div class=" site-header-nav-item hvr-underline-from-center">
                <a href="/front.html"
                   target="_self"
                   title="大前端">
                    大前端
                </a>
                
            </div>
            
        </nav>
    </div>
</header>


        <div class="content">
            <section class="jumbotron geopattern" data-pattern-id="飞天班第36节：Redis（3）">
    <div class="container">
        <div id="jumbotron-meta-info">        
            <h1>飞天班第36节：Redis（3）</h1>
            <span class="meta-info">
                
                
                <span class="octicon octicon-calendar"></span> 2020/05/17
                
            </span>
        </div>
    </div>
</section>
<script>
    $(document).ready(function(){

        $('.geopattern').each(function(){
            $(this).geopattern($(this).data('pattern-id'));
        });

    });
</script>
<article class="post container noneed" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="row">

        
        <div class="col-md-9 markdown-body">

            <h2 id="1redis持久化">1、Redis持久化</h2>

<p>Redis是一个非关系型内存数据库，断电即失，文件存储！持久化是一个刚需！</p>

<h3 id="rdb">RDB</h3>

<blockquote>
  <p>什么是rdb</p>
</blockquote>

<p>Redis database，在指定的时间间隔将数据集写入磁盘，redis.conf配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># rdb 持就化配置</span>
save 900 1		<span class="c"># 900秒内，只要发生一次变化，就会触发一次 rdb操作(bgsave)</span>
save 300 10		<span class="c"># 300秒内，只要发生10次变化，就会触发一次 rdb操作</span>
save 60 10000 <span class="c"># 60秒内，只要发生10000次变化，就会触发一次 rdb操作</span>

<span class="c"># 生成一个文件</span>
dbfilename dump.rdb <span class="c"># 默认的文件名 </span>
</code></pre></div></div>

<p>redis启动的时候，就会加载这个rdb文件（恢复数据的过程）</p>

<p><img src="/assets/images/2020/redis/rdb-redis-start.gif" alt="" /></p>

<p>Rdb是整合内存的压缩过的快照信息，具体原理：</p>

<p><img src="/assets/images/2020/redis/red-flow.gif" alt="" /></p>

<p>1、fork一个子进程持久化</p>

<p>2、备份和替换</p>

<font color="red">缺陷：可能会丢失最后一次同步的数据</font>

<p><img src="/assets/images/2020/redis/red-flow-lost-last-rdb.gif" alt="" /></p>

<blockquote>
  <p>手动触发Rdb</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1、配置文件save定义的触发规则生效，产生dump.rdb 【被动】</span>
<span class="c"># 2、save命令，执行的时候会阻塞Redis的服务，直到RDB文件完成才会释放我们Redis进程恢复读写操作【主动】</span>
<span class="c"># 3、bgsave命令，执行的时候会在后台fork一个进程进行RDB的生成，不影响主进程的业务操作【主动】</span>
</code></pre></div></div>

<p>返回最近一次 Redis 成功将数据保存到磁盘上的时间</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; lastsave
<span class="o">(</span>integer<span class="o">)</span> 1589718280
</code></pre></div></div>

<p>4、flushall 命令触发rdb操作（flushdb不会触发）</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; flushall <span class="c"># 清空所有数据库的数据，会再产生一个空的dump.db,但是没有什么意义</span>
</code></pre></div></div>

<p>5、退出redis也会触发rdb操作</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; shutdown
</code></pre></div></div>

<blockquote>
  <p>恢复的规则</p>
</blockquote>

<p>启动的时候，会自动加载当前目录下的dump.rdb文件，恢复数据</p>

<p>具体放置的目录</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; config get <span class="nb">dir</span>
<span class="s2">"dir"</span>
<span class="s2">"/usr/local/bin"</span>
</code></pre></div></div>

<blockquote>
  <p>分析</p>
</blockquote>

<p>1、大规模的数据恢复，合适</p>

<p>2、对数据完整性和一致性的要求不高的情况下</p>

<p>3、按照save配置定时做备份，redis意外down掉，最后一次的快照数据就有可能丢失</p>

<p>4、采用fork子进程的方式备份数据，内存中的数据被克隆了一份，所以说空间可能会占有较大</p>

<h3 id="aof">AOF</h3>

<p>Append Only File，我们每一个步骤，它都会记录下来（读取的命令是不会记录），不断的在这个文件进行追加内容。</p>

<p>恢复的时候，就按照这个文件中记录的指令一个一个的读取（执行一遍）</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 配置 aof 开启</span>
appendonly <span class="nb">yes</span>
<span class="c"># aof的文件名</span>
appendfilename <span class="s2">"appendonly.aof"</span>
</code></pre></div></div>

<p><img src="/assets/images/2020/redis/append-only-file.gif" alt="" /></p>

<p>重启redis的时候，它会读取这个文件，假设redis启动失败，可能原因：文件错误</p>

<p>我们可以通过 <mark>redis-check-aof</mark>来修改文件</p>

<p><img src="/assets/images/2020/redis/aof-fix.gif" alt="" /></p>

<font color="red">但修复工具会删除一些错误数据，删除的就是错误数据之后的所有数据，所以不要随意修改appendonly.aof</font>

<blockquote>
  <p>其他配置规则</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis.conf，redis官方写入 8万次/秒</span>
appendfsync always    <span class="c"># 每次写入都执行同步，相对效率低</span>
appendfsync everysec  <span class="c"># 每秒执行一次sync,问题：可能会导致这1s丢失</span>
appendfsync no  <span class="c"># 不执行同步，redis直接持久化到磁盘</span>

no-appendfsync-on-rewrite no <span class="c"># 重写时是否执行同步，yes不执行同步，no 执行同步，默认no,保证数据的安全</span>
什么时候会触发重写，下面两个配置
<span class="c"># 重写机制(压缩机制):避免文件越来越大,将key的重复值合并（同一个key只保留最后一次写操作）,重写的时候会触发fork一个新进程来操作，与RDB的fork进程区别是前者复制写操作，后者复制数据本身</span>
<span class="c"># 重写触发条件就是下面两个都满足才触发</span>
<span class="c"># 上面配置no,重写触发后会fork进程并阻塞主进程无法写入导致等待,所以两个值可以设置小点让重写快速阻塞完毕</span>
<span class="c"># 1.现有的文件比上次多出100%：上次压缩完2G，现在已经4G了如果是50%就是3G</span>
auto-aof-rewrite-percentage 100
<span class="c"># 2.现有的文件已经超过100mb了，避免设置过小，频繁触发重写，也不能过大，避免重写的时候阻塞时间过长</span>
auto-aof-rewrite-min-size 100mb

<span class="c"># 上面配置：aof文件大于100mb 且 比上次比较多出100%，才会触发aof文件的重写</span>
</code></pre></div></div>

<blockquote>
  <p>分析</p>
</blockquote>

<p>1、相同的数据，aof文件远远大于rdb的文件，恢复速度也是比较慢的</p>

<p>2、每秒执行一次sync同步，问题：可能导致这1秒丢失</p>

<p>3、aof运行的效率慢于rdb，但是同步策略比rdb好一点（每秒同步，数据更完整）</p>

<p>​    如果不同步（上面的配置appendfsync no），性能是一样的。</p>

<h3 id="总结">总结</h3>

<p>1、RDB持久化，save配置可以进行指定时间间隔来进行持久化存储</p>

<p>2、AOF持久化，记录每一次的命令，读取的时候一行行读取恢复。由于有重写机制，可以保证这个文件不会太大</p>

<p>3、如果你是使用Redis只做缓存，可以选择不做持久化</p>

<p>4、同时开启了两种持久化方式：</p>

<ul>
  <li>redis启动的时候有优先加载aof文件，先恢复原始数据，通常情况下aof文件保存的数据集一定比rdb文件完整，rdb是定期备份的。</li>
  <li>推荐不要只使用aof，因为如果aof文件损坏，可能数据就没了（redis启动不了），这时rdb就显得特别重要了</li>
</ul>

<p>5、性能</p>

<ul>
  <li>
    <p>Rdb 用做后备使用，一般在slave 从节点配置，我们也不需要改动原来默认的配置，保留 15分钟备份一次即可。（我们使用redis的模式： 主从复制 + 哨兵模式）</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>save 900 1
<span class="c"># save 300 10</span>
<span class="c"># save 60 10000</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果你开启了AOF，最多的数据丢失不会超过2秒，启动时也只是加载了aof文件（单机你就开启aof吧），auto-aof-rewrite-min-size 一般设置 几个G都是ok的</p>
  </li>
  <li>
    <p>默认不开启AOF，我们可以使用主从来实现高可用，好处就是减少IO资源，减少了重写的空间浪费。假设 主从节点都出现了问题，也就是丢失了15分钟的数据，启动的时候查看哪个一个从节点的rdb更加完整来进行选择加载，微博就是这样做的。</p>

    <p>所以说：Redis的持久化是默认不开启AOF的，是使用RDB来处理持久化！</p>
  </li>
</ul>

<h2 id="2redis事务">2、Redis事务</h2>

<h3 id="事务本质">事务本质</h3>

<p>Redis的事务本质是一组命令的集合，可以一次性支持多个指令。串行执行，从上到下依次执行。</p>

<p><img src="/assets/images/2020/redis/multi-zhiling.gif" alt="" /></p>

<p>Redis事务没有隔离性的概念。为什么？</p>

<p>因为所有的命令在事务真正执行之前都是没有操作，在队列缓存中。</p>

<p>Redis的事务流程：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 开启一个事务</span>
<span class="c"># 一堆指令</span>
<span class="c"># 执行事务</span>
multi <span class="c"># 标记事务的开始</span>
<span class="nb">exec</span>  <span class="c"># 执行事务，结束</span>
discard <span class="c"># 放弃事务，取消这个事务</span>
</code></pre></div></div>

<p><strong>正常执行</strong></p>

<p><img src="/assets/images/2020/redis/multi-exec1.gif" alt="" /></p>

<p><strong>放弃事务</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; multi		<span class="c"># 开始事务</span>
127.0.0.1:6379&gt; <span class="nb">set </span>k1 v1
127.0.0.1:6379&gt; <span class="nb">set </span>k2 v2
127.0.0.1:6379&gt; <span class="nb">set </span>k4 v4
127.0.0.1:6379&gt; discard			<span class="c"># 放弃事务，队列就没了 </span>
127.0.0.1:6379&gt; get k4
<span class="o">(</span>nil<span class="o">)</span>
</code></pre></div></div>

<blockquote>
  <p>Redis不保证原子性</p>
</blockquote>

<p>Redis的单条命了一定是原子性的，但是事务中，如果其中一个命令执行失败，其与的命令依旧执行。</p>

<p>命令执行失败有两种情况</p>

<ul>
  <li>
    <p>编译型错误（<font color="red">命令错误</font>），事务自动回滚，exec执行不会成功，例子如下：</p>

    <p><img src="/assets/images/2020/redis/multi-exec-compile-error.gif" alt="" /></p>
  </li>
  <li>
    <p>运行时错误，不保证原子性的证明</p>

    <p><img src="/assets/images/2020/redis/multi-exec-runtime-error.gif" alt="" /></p>
  </li>
</ul>

<h3 id="乐观锁">乐观锁</h3>

<ul>
  <li>
    <p><strong>乐观锁</strong></p>

    <p>非常乐观，每次获取数据都认为这个数据没有变化，没有被人修改过，所以不会上锁。但是更新的时候需要去比较这个数据期间是否被人更新过，版本号机制：提交的版本一定要大于当前记录版本才可以修改。</p>

    <p>乐观锁使用的场景：读非常多的情况下，这样可以提高吞吐量！</p>
  </li>
  <li>
    <p><strong>悲观锁</strong></p>

    <p>非常悲观，每次获取这个数据都认为会被人修改，每次获取数据都会上锁，如果别人要获取这个数据，就必须要等到解锁才可以拿到。传统关系型数据库都是这种锁机制，行锁，表锁，java的读写锁，synchronized都是悲观锁，操作之前先上锁。</p>
  </li>
</ul>

<p>Redis实现乐观锁操作</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>watch		<span class="c"># 监控数据</span>
unwatch  <span class="c"># 取消监控</span>
</code></pre></div></div>

<blockquote>
  <p>正常执行</p>
</blockquote>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 初始化测试环境</span>
127.0.0.1:6379&gt; <span class="nb">set </span>money 100
127.0.0.1:6379&gt; <span class="nb">set </span>use 0
127.0.0.1:6379&gt; watch money   <span class="c"># 事务开始之前监控money，事务过程中这个money没有发生变化，这个事务才可以执行成功，否则事务自动取消</span>
127.0.0.1:6379&gt; multi
127.0.0.1:6379&gt; decrby money 20
QUEUED
127.0.0.1:6379&gt; incrby use 20
QUEUED
127.0.0.1:6379&gt; <span class="nb">exec
</span>1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 80
2<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 20
</code></pre></div></div>

<blockquote>
  <p>失败测试</p>
</blockquote>

<p><img src="/assets/images/2020/redis/multi-watch-back.gif" alt="" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 如果执行失败，需要放弃监控</span>
127.0.0.1:6379&gt; unwatch
<span class="c"># 重写监控</span>
127.0.0.1:6379&gt; watch m
127.0.0.1:6379&gt; multi
127.0.0.1:6379&gt; decrby m 20
QUEUED
127.0.0.1:6379&gt; incrby u 20
QUEUED
127.0.0.1:6379&gt; <span class="nb">exec
</span>1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 180
2<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> 20

<span class="c"># mysql</span>
<span class="k">select </span>version   <span class="c"># 获取版本号 1</span>
update version <span class="o">=</span> version + 1 where version <span class="o">=</span> 1
<span class="k">while</span><span class="o">()</span> <span class="o">{</span>
		// 获取最新版本，直到修改成功
<span class="o">}</span>
</code></pre></div></div>

<p><strong>小结</strong>：</p>

<p>我们一旦执行exec，无论你事务是否执行成功，watch都会取消监控，我们需要重新watch这个变量</p>

<p>watch就是类似于我们之前学习的乐观锁机制。</p>

<h2 id="3发布订阅">3、发布订阅</h2>

<p><img src="/assets/images/2020/redis/subscribe-pubsub.gif" alt="" /></p>

<p>使用微信公众号：</p>

<p><img src="/assets/images/2020/redis/wx-public.gif" alt="" /></p>

<p>这种模型下，我们是允许用户收到有延迟的，可以使用Redis的发布订阅功能！</p>

<p>比如说：网站内部信。</p>

<p>两个角色：</p>

<ul>
  <li>发布者</li>
  <li>订阅者</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subscribe <span class="c"># 订阅消息，</span>
publish <span class="c"># 发布消息</span>
unsubscribe <span class="c"># 退订指定频道</span>
</code></pre></div></div>

<p>例子：
<img src="/assets/images/2020/redis/subscribe-publish.gif" alt="" /></p>

<p>原理：底层是redis.pubsub.c 源码文件。它的核心是使用key作为chanel，而字典的值是一个链表，链表中维护订阅了这个key的所有客户端，每订阅一个，subscribe就把客户端添加到chanel的链表中。</p>

<p>publish发送消息，redis会找到这个chanel（key）的 链表，将消息发送给每个客户端</p>

<p><img src="\assets\images\2021\redis\pubsub-channels.png" alt="" /></p>

<p>应用场景：实现消息系统，及时聊天，群聊</p>

<p>相比专业消息队列（如rabbitmq），它的功能就比较局限了。</p>

<h2 id="4主从复制重点">4、主从复制（重点）</h2>

<p>主从复制，将一台Redis服务器的数据复制到其他的Redis服务器。</p>

<p>单向复制：只能是主节点到从节点。Master: 写，Slave: 读</p>

<p>主从复制的好处：</p>

<ul>
  <li>数据冗余：数据备份，除了持久化之外的数据冗余方式</li>
  <li>故障恢复：Master出现问题，从机可以顶替主节点工作</li>
  <li>负载均衡：主节点提供写服务，从节点提供读服务，分担服务器负载压力</li>
  <li>高可用基础：集群是高可用的基础</li>
</ul>

<font color="red">**Redis在生产中使用，是必须要搭建集群，单机只适合学习**</font>

<p>假设Redis所在服务器256G内存，我们不能讲所有内存分配给Redis，一般只想20G即可。真正的使用中，读多写少。</p>

<h3 id="命令方式配置">命令方式配置</h3>

<p>1、启动集群</p>

<p>复制redis.conf为3个文件，以redis端口号.conf的格式命名，分别启动3个Redis实例，如下图</p>

<p><img src="/assets/images/2020/redis/redis-3-master.gif" alt="" /></p>

<p>连接客户端</p>

<p><img src="/assets/images/2020/redis/redis-cli-master-slave.gif" alt="" /></p>

<p>查看当前每个节点的信息 <mark>info replication</mark></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1:6379&gt; info replication
<span class="c"># Replication</span>
role:master
connected_slaves:0
min_slaves_good_slaves:0
master_replid:15894a199166379e8e75f2c9ed8713828f81da87
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:5242880
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

<span class="c"># 默认情况下，三个节点都是 master</span>
</code></pre></div></div>

<p>2、配一主二从</p>

<p>有两种方式配置</p>

<ul>
  <li>命令方式，<mark>slaveof</mark> master-ip master-port  （重启实例后回master 角色，需要重新执行命令连接主节点）</li>
  <li>配置文件修改，配置<mark> replicaof</mark> master-ip master-port</li>
</ul>

<p>这里使用命令方式</p>

<p><img src="/assets/images/2020/redis/mster-repi.gif" alt="" /></p>

<p>3、<font color="red">测试：从节点不能写入，主节点中设置的会自动同步到从节点中</font></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis.conf 默认开启并配置为yes, 从节点不能写</span>
<span class="c"># slave节点只允许read 默认就是 yes，这个配置只对slave节点才生效，对master节点没作用</span>
replica-read-only <span class="nb">yes</span> 
</code></pre></div></div>

<p><img src="/assets/images/2020/redis/master-repl2.gif" alt="" /></p>

<p>数据同步：</p>

<ul>
  <li>全量复制：从节点第一次连接到主节点的时候，会将主节点的所有内容全部同步一次</li>
  <li>增量复制：第一次同步数据后，每次连接，主节点的所有命令同步增加进来</li>
</ul>

<p>4、<strong>服务器（节点）挂了</strong></p>

<ul>
  <li>
    <p>主节点挂了，从节点等待主节点恢复（十分笨，不智能，后面使用哨兵模式实现主从自动切换解决），如果主节点恢复，数据会继续同步。</p>

    <blockquote>
      <p>主节点挂了，从节点升级当老大，手动版</p>
    </blockquote>

    <p>使用 <mark>SLAVEOF NO ONE</mark>命令，从节点恢复到master，然后手动配置其他从节点连接到这个节点上</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1、恢复到master</span>
127.0.0.1:7002&gt; slaveof no one
OK
127.0.0.1:7002&gt; info replication
<span class="c"># Replication</span>
role:master
connected_slaves:0
min_slaves_good_slaves:0
master_replid:9a7763c54ae32880a72566fefa8443f76fa844b1
master_replid2:b8949076868b0fd644f8576c0cad1b76a4c1216a
master_repl_offset:61552242
  
<span class="c"># 2、其他节点连接到这个节点上</span>
127.0.0.1:7001&gt; slaveof 127.0.0.1 7002
OK
127.0.0.1:7001&gt; info replication
<span class="c"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:7002
master_link_status:up
  
<span class="c"># 3、查看7002的节点信息，已有一个从节点了</span>
127.0.0.1:7002&gt; info replication
<span class="c"># Replication</span>
role:master
connected_slaves:1
min_slaves_good_slaves:1
slave0:ip<span class="o">=</span>127.0.0.1,port<span class="o">=</span>7001,state<span class="o">=</span>online,offset<span class="o">=</span>61552270,lag<span class="o">=</span>0
master_replid:5d555dbd6508b02cc2424a829a8bf61efbaaa706
</code></pre></div>    </div>
  </li>
  <li>
    <p>从节点挂了，然后恢复，内容是否还可以同步？可以，从节点重新连接到主节点，数据会自动同步过来。（如果是通过命令方式配置从节点的，重启后需要手动配置，重新成为从节点）</p>
  </li>
</ul>

<blockquote>
  <p>其他集群方式，仅学习使用，生产环境不能使用</p>
</blockquote>

<p><img src="/assets/images/2020/redis/other-master-slave.gif" alt="" /></p>

<p>查看 info replication</p>

<p><img src="/assets/images/2020/redis/other-master-slave2.gif" alt="" /></p>

<p>测试，数据会从6379 同步到 6380，6380会把数据同步都6381</p>

<p><img src="/assets/images/2020/redis/other-master-slave3.gif" alt="" /></p>

<p><mark>注意</mark>：如果Redis是有密码的，主从节点的配置文件都要配置</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis.conf</span>
masterauth xxxx <span class="c"># 主节点的访问密码</span>
</code></pre></div></div>

<h3 id="主从节点的全部配置">主从节点的全部配置</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 可以通过命令看一下主从信息，v5.x版本前从是用slave表示，之后换成replication</span>
<span class="c"># 1、master和slave节点都可以查看，要考虑主从切换的情况</span>
info replication

<span class="c"># 2、修改slave的redis.conf</span>
replicaof 192.168.1.100 6379 <span class="c">#master的ip，master的端口</span>

<span class="c"># 3、在master和slave配置上添加，避免主节点宕机后重启成为从节点，配置文件没有设置密码的话就无法连接到新的主节点了</span>
masterauth icoding <span class="c">#主机的访问密码</span>

<span class="c"># 4、默认开启yes,在slave上配置</span>
<span class="c"># yes 主从复制中，从服务器可以响应客户端请求</span>
<span class="c"># no 主从复制中，从服务器将阻塞所有请求，有客户端请求时返回“SYNC with master in progress”；</span>
replica-serve-stale-data <span class="nb">yes</span>

<span class="c"># 5、默认开启并配置为yes,在slave上配置</span>
<span class="c"># slave节点只允许read 默认就是 yes，这个配置只对slave节点才生效，对master节点没作用</span>
replica-read-only <span class="nb">yes</span> 

<span class="c"># 6、默认没有开启,在slave的配置上打开</span>
<span class="c"># slave根据指定的时间间隔向master发送ping请求，默认10秒，相当于心跳检测</span>
repl-ping-replica-period 10

<span class="c"># 7、默认没有开启,在slave的配置上打开</span>
<span class="c"># 复制连接超时时间。</span>
<span class="c"># master和slave都有超时时间的设置。</span>
<span class="c"># master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。</span>
<span class="c"># slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。</span>
<span class="c"># 需要注意的是repl-timeout需要设置为比repl-ping-slave-period更大的值，不然会经常检测到超时。</span>
repl-timeout 60

<span class="c"># 8、是否禁止复制tcp链接的tcp nodelay参数，默认开启并配置为no,在master上配置</span>
<span class="c"># 默认是no，即使用tcp nodelay,允许小包的发送。对于延时敏感型，同时数据传输量比较小的应用，开启TCP_NODELAY选项无疑是一个正确的选择</span>
<span class="c"># 如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。</span>
<span class="c"># 但是这也可能带来数据的延迟。</span>
<span class="c"># 默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。</span>
repl-disable-tcp-nodelay no

<span class="c"># 9、默认没有开启,在master上配置</span>
<span class="c"># 复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。</span>
<span class="c"># 这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。</span>
<span class="c"># 缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。</span>
<span class="c"># 没有slave的一段时间，内存会被释放出来，默认1m。</span>
repl-backlog-size 5mb

<span class="c"># 10、默认没有开启,在master上配置</span>
<span class="c"># master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。</span>
<span class="c"># 单位为秒。</span>
repl-backlog-ttl 3600

<span class="c"># 11、默认开启，在slave上配置</span>
<span class="c"># 当master不可用，Sentinel会根据slave的优先级选举一个master。</span>
<span class="c"># 最低的优先级的slave，当选master。</span>
<span class="c"># 而配置成0，永远不会被选举。</span>
<span class="c"># 注意：要实现Sentinel自动选举，至少需要2台slave。</span>
replica-priority 100

<span class="c"># 12、默认没有开启，在master上配置</span>
<span class="c"># redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。</span>
<span class="c"># master最少得有多少个健康的slave存活才能执行写命令。</span>
<span class="c"># 这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。</span>
<span class="c"># 设置为0是关闭该功能，默认也是0。</span>
min-replicas-to-write 2

<span class="c"># 13、默认没有开启，在master上配置</span>
<span class="c"># 延迟小于min-replicas-max-lag秒的slave才认为是健康的slave。</span>
min-replicas-max-lag 10
</code></pre></div></div>

<h2 id="5哨兵模式">5、哨兵模式</h2>

<h3 id="哨兵机制">哨兵机制</h3>

<p>上面的状态，主从节点挂了，我们只能手动配置，很原始的做法。能不能自动完成？</p>

<p>使用哨兵模式：</p>

<ul>
  <li>
    <p>检测集群监控状况</p>

    <p><img src="/assets/images/2020/redis/sentinel-works.gif" alt="" /></p>
  </li>
  <li>
    <p>自动选举主节点（哨兵也是集群，至少3个节点，使用投票机制）</p>
  </li>
</ul>

<p><img src="/assets/images/2020/redis/sentinel-works2.gif" alt="" /></p>

<p>​	<mark>哨兵监视集群，哨兵之间相互监督</mark></p>

<h3 id="配置哨兵">配置哨兵</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># redis的安装根目录下，有个sentinel.conf</span>
<span class="c"># 部署三个哨兵节点(sentinel要从redis的slave里选举一个node成为master，所以至少3个哨兵节点)，同时监控一组redis服务（只有一个节点其实也可以，但有风险）</span>
<span class="nb">cp </span>sentinel.conf /usr/local/redis-6379
vi sentinel.conf
<span class="c"># bind 127.0.0.1 192.168.1.1</span>
<span class="c"># 测试的时候放开访问保护,</span>
protected-mode no
port 26379 <span class="c">#默认是26379</span>
daemonize <span class="nb">yes</span>  <span class="c"># 守护进程的方式启动（后台）</span>
pidfile /var/run/redis-sentinel-26379.pid <span class="c">#pid 集群要区分开</span>
logfile /usr/local/redis-6379/sentinel/redis-sentinel.log <span class="c">#日志，非常重要</span>
<span class="nb">dir</span> /usr/local/redis-6379/sentinel <span class="c">#工作空间</span>

<span class="c"># sentinel监控的核心配置</span>
<span class="c"># 1、最后一个2，quorum,&gt;=2个哨兵主观认为master下线了，master才会被客观下线，才会选一个slave成为master</span>
sentinel monitor icoding-master 127.0.0.1 6379 2
<span class="c"># 2、master访问密码</span>
sentinel auth-pass icoding-master icoding
<span class="c"># 3、sentinel主观认为master挂几秒以上才会触发选举切换主节点</span>
sentinel down-after-milliseconds icoding-master 3000
<span class="c"># 4、所有slave同步新master的并行同步数量，如果是1就一个一个同步，在同步过程中slave节点是阻塞的不可用的，同步完了才会放开</span>
sentinel parallel-syncs icoding-master 1
<span class="c"># 5、同一个master节点failover之间的时间间隔,默认3分钟，举个例子，master节点A宕机了，重启后成为slave节点，它要重新成为master节点需要等3分钟</span>
sentinel failover-timeout icoding-master 180000
</code></pre></div></div>

<p>测试的时候可以使用1个哨兵，多个哨兵只需修改配置文件的端口就可以了。</p>

<p>1、启动</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 跟redis-server一样，安装好redis后在/usr/local/bin就redis-sentinel的启动项</span>
redis-sentinel sentinel.conf
<span class="c"># 如果要搭建集群，只需要将刚刚配置的sentinel.conf复制到其他节点即可</span>
</code></pre></div></div>

<p>哨兵集群部署的约定</p>

<ul>
  <li>哨兵集群至少3个节点</li>
  <li>最好三个节点在不同的物理机器上</li>
  <li><strong>一组哨兵最好只监控一组主从</strong></li>
</ul>

<p>2、测试主节点挂6379了之后</p>

<p><img src="/assets/images/2020/redis/sentinel-covert-master.gif" alt="" /></p>

<p>哨兵自动切换主节点到6380</p>



            <div>
   <!-- <p align="center">
     	  
         <img src="/assets/images/keeppuresmile.jpg" >
         <br/>
         微信扫描二维码，关注一个有故事的程序员
        

   </p>
   <p align="center" style="margin-top: 15px; font-size: 11px;color: #cc0000;">
       <strong>（转载本站文章请注明作者和出处 <a href="http://www.ityouknow.com">纯洁的微笑-ityouknow</a>）</strong>
   </p>
   <p align="center" style="margin-top: 15px; font-size: 16px;color: #337ab7;">
       <strong><a href="http://www.justdojava.com/" target="_blank">点击了解 ：Java 技术人的网站</a></strong>
   </p> -->
</div>

            <!-- Comments -->
            <div class="comment">
             

  

  
        <div id="gitalk-container"></div>
        <script src="/assets/js/gitalk.min.js"></script>
        <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> -->
        <script>
        var gitalk = new Gitalk({
            id: '/icoding-edu/2020/05/17/icoding-note-036.html',
            clientID: '6cd8ad4d1cf1d1e6ad95',
            clientSecret: 'c4ce22a25efe50bfd60da67c990b534bc99a6424',
            repo: 'aikomj.github.io',
            owner: 'aikomj',
            admin: ['aikomj'],
            labels: ['gitalk'],
            perPage: 50,
        })
        gitalk.render('gitalk-container')
        </script>
  


            </div>
        </div>

        <div class="col-md-3">
            <h3>Post Directory</h3>
<div id="post-directory-module">
<section class="post-directory">
    <!-- Links that trigger the jumping -->
    <!-- Added by javascript below -->
    <dl></dl>
</section>
</div>

<script type="text/javascript">

    $(document).ready(function(){
        $( "article h2" ).each(function( index ) {
            $(".post-directory dl").append("<dt><a class=\"jumper\" hre=#" +
                    $(this).attr("id")
                    + ">"
                    + $(this).text()
                    + "</a></dt>");

            var children = $(this).nextUntil("h2", "h3")

            children.each(function( index ) {
                $(".post-directory dl").append("<dd><a class=\"jumper\" hre=#" +
                        $(this).attr("id")
                        + ">"
                        + "&nbsp;&nbsp;- " + $(this).text()
                        + "</a></dd>");
            });
        });

        var fixmeTop = $('#post-directory-module').offset().top - 100;       // get initial position of the element

        $(window).scroll(function() {                  // assign scroll event listener

            var currentScroll = $(window).scrollTop(); // get current position

            if (currentScroll >= fixmeTop) {           // apply position: fixed if you
                $('#post-directory-module').css({      // scroll to that element or below it
                    top: '100px',
                    position: 'fixed',
                    width: 'inherit'
                });
            } else {                                   // apply position: static
                $('#post-directory-module').css({      // if you scroll above it
                    position: 'inherit',
                    width: 'inherit'
                });
            }

        });

        $("a.jumper").on("click", function( e ) {

            e.preventDefault();

            $("body, html").animate({
                scrollTop: ($( $(this).attr('hre') ).offset().top - 100)
            }, 600);

        });
    });

</script>
        </div>
        

    </div>
     <!--<div class="asb-post-01">-->
        <!--<div class="mask"></div>-->
            <!--<div class="info">-->
                <!--<div>扫码关注公众号：<span style="color: #E9405A; font-weight: bold;">纯洁的微笑</span></div>-->
            <!--<div>-->
            <!--<span>发送 </span><span class="token" style="color: #e9415a; font-weight: bold; font-size: 17px; margin-bottom: 45px;">290992</span>-->
            <!--<div>-->
                <!--即可<span style="color: #e9415a; font-weight: bold;">立即永久</span>解锁本站全部文章-->
            <!--</div>-->
            <!--<img class="code-img" style="width: 300px;display:unset" src="/assets/images/keeppuresmile.jpg">-->
        <!--</div>-->
    <!--</div>-->
</article>

        </div>

    
<footer class="container">
    <div class="site-footer">
       <!--  <div class="site-footer-icons">
            <a target="_blank" href="https://www.zhihu.com/people/ityouknow">
               知乎
            </a>
            <a target="_blank" href="http://weibo.com/ityouknow">
               微博
            </a>
            <a target="_blank" href="https://github.com/ityouknow">
                GitHub
            </a>
        </div> -->
        <!-- <div class="card text-center">
            <ul class="list-inline" style="margin-left: 0;">
               <li>
                <a target="_blank" href="https://github.com/ityouknow">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a target="_blank" href="https://www.zhihu.com/people/ityouknow">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa  fa-stack-1x fa-inverse">知</i>
                  </span>
                </a>
              </li>
                  <li>
                <a target="_blank" href="https://weibo.com/ityouknow">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          </ul>
        </div> -->
        <div class="site-footer-links mobile-hidden">
            
        </div>
        <div class="scrolltop">
            <a href="javascript:window.scrollTo(0,0)" >TOP</a>
        </div>
        <div class="rss">
            <a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a>
            Power by <a href="https://github.com/DONGChuan/Yummy-Jekyll">Yummy Jekyll</a>
        </div>
    </div>
    <!-- Third-Party JS -->
    <script type="text/javascript" src="/bower_components/geopattern/js/geopattern.min.js"></script>
    <!-- My JS -->
    <script type="text/javascript" src="/assets/js/script.js"></script>
    
    
     <!-- Cnzz Analytics -->
       <div style="display:none">
         <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260945749'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1260945749' type='text/javascript'%3E%3C/script%3E"));</script>
       </div>
     <!-- Cnzz Analytics -->
</footer>


    </body>

</html>
