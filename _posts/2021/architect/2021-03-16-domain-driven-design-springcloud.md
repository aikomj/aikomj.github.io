---
layout: post
title: DDD领域驱动如何将业务拆分成微服务
category: architect
tags: [architect]
keywords: architect,springcloud
excerpt: DDD分层微服务，项目实战
lock: noneed
---

## 1、领域驱动设计

Domain Driven Design 领域驱动设计，简称DDD，就是基于模型驱动开发的设计思想。

domain 就是实体类或者PO持久化对象，也称模型，通常对应数据库表。domain就是数据模型，领域就是问题域，系统要解决的问题就是核心业务。

### 术语

- 事件风暴 Event Storm，指团队一起划分微服务的限界上下文
- 实体 Entity，就是持久化对象，对应数据表，每个实体都有一个id唯一标识，如一件商品
- 值对象 Value Object，
- 聚合 Aggregate, 就是有紧密关系的实体和值对象的组合，一个聚合就是一个领域，聚合包含的实体和值对象就是领域对象。
- 限界上下文 Bounded Context ，领域的边界
- 领域服务 Service，聚合提供的服务，实现全部的业务逻辑，解决业务问题的服务
- 领域事件 Event

### 领域建模

1. 划分好边界上下文
2. 在每个边界上下文中设计领域模型
3. 画出领域模型图，圈出每个模型中的聚合边界
4. 设计领域模型时，要考虑该领域模型是否满足业务规则，同时还要综合考虑技术实现等问题，比如并发问题；领域模型不是概念模型，概念模型不关注技术实现，领域模型关心；所以领域模型才能直接指导编码实现；
5. 思考领域模型是如何在业务场景中发挥作用的，以及是如何参与到业务流程的每个环节的
6. 场景走查，确认领域模型是否能满足领域中的业务场景和业务流程；
7. 模型持续重构、完善、精炼；

一个普通电商系统的商品中心的领域模型图，给大家参考：

![](\assets\images\2021\springcloud\domain-product-model.bmp)



## 2、拆分成微服务

### DDD分层架构模型

![](\assets\images\2021\springcloud\ddd-structure.jpg)

- 应用层

  尽量简单，它协调和指挥领域层的领域对象来完成业务逻辑，本身不包含业务规则。提供与业务无关的服务，如安全认证、权限校验、分布式和持久化事务控制或向外部应用发送基于事件的消息等。

- 领域层

  整个服务的核心所在，实现全部业务逻辑。它包含领域对象（实体、值对象）、领域服务。<mark>它负责表达业务概念、业务状态以及业务规则，具体表现形式就是领域模型。</mark>

- 基础设施层

  为各层提供通用的技术能力，包括：为应用层传递消息、提供 API 管理，为领域层提供数据库持久化机制等。它还能通过技术框架来支持各层之间的交互。

### 服务视图

一个微服务内有 Facade 接口（web接口）、应用服务、领域服务和基础服务，各层服务协同配合，为外部提供服务。如下图：

![](\assets\images\2021\springcloud\ddd-service-lay.jpg)

- 接口服务(web接口)

  位于Interfaces用户接口层，处理用户发送的 Restful 请求和解析用户输入的配置文件等，并将信息传递给应用层。

- 应用服务

  位于Application应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。  

  这里的服务包括**应用服务**和**领域事件服务**。

  1) **应用服务**可<mark>对微服务内的领域服务以及微服务外的应用服务（Feign方式调用）进行组合和编排</mark>，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务， 本身不包含业务逻辑

  2) **领域事件服务**包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。

- 领域服务

  位于Domain领域层，为完成领域中跨实体或值对象的操作转换而封装的服务。

  领域服务就是对同一个实体的一个或多个方法进行<mark>组合和封装</mark>，或者对多个不同实体的操作进行组合或编排，对外暴露成服务，这些服务封装了核心的业务逻辑。

  实体自身的行为在实体类内部实现，向上封装成领域服务暴露。

   为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。 为实现微服务内聚合之间的解耦，原则上**禁止跨聚合的领域服务调用和跨聚合的数据相互关联**。所以一个领域就是一个聚合，由紧密关系的实体和值对象组合成。

- 基础服务

  唯一Infrastructure基础层，为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。 基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象（DAO层）或直接访问基础资源。

> 微服务外的应用服务视图

主要有两个：

- 前端应用

  微服务中的应用服务通过用户接口层组装和数据转换后，发布在 API 网关，为前端应用提供数据展示服务。

- 外部应用

  当我们需要跨微服务数据处理时，通常会有两个场景

  1) 对实时性要求的场景，选择直接调用应用服务的方式，如果是新增修改，因为是跨微服务会产生分布式事务，为保证事务的强一致性，需要整合分布式事务框架。

  2) 对实时性要求不高的场景，选择异步化的领域事件驱动机制，通过消息队列实现异步数据传输，实现最终数据一致性

### 数据视图

DDD 分层架构中数据对象转换的过程如下图。

![](D:\jacob\code\aikomj.github.io\assets\images\2021\springcloud\ddd-dto.png)



### 目录分层

基于DDD的一个微服务目录结构一般分4层，如下

![](\assets\images\2021\springcloud\domain-driven-design-1.jpg)

> 1) Interfaces用户接口层

相当于web的controller控制层，接受Request请求，将数据传递给Application层。

**子目录包括：**

- assembler，实现 dto 与领域对象(实体和值对象)之间的相互转换和数据交换
- dto 数据传输对象，内部不存在任何业务逻辑，dto让领域对象与外界隔离
- facade 门面模式，对外提供统一的调用接口，将用户请求委派给一个或多个Service应用服务进行处理

> 2) Application应用层

相对于web的Service层，主要代码形态是应用服务和领域事件等。

**子目录包括：**

- Event 事件，包括两种类型 publish发布 和 subscribe订阅,
- Service 应用服务，对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。

> 3) Domain领域层

主要实现核心领域逻辑，其主要代码形态是实体类方法和领域服务。

子目录包括：

- aggregate 聚合，聚合代码包的根目录，实际项目中以实际业务属性的名称来命名

- entity 实体，存放实体（含聚合根、实体和值对象）相关代码
- serivce 领域服务，根据业务逻辑对多个实体的操作进行组合编排封装，对外保留的服务
- repository 仓储，存放聚合对应的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定一个原则：一个聚合对应一个仓储。

> 4) Infrastructure基础层 [ˈɪnfrəstrʌktʃər]







**参考**

[https://www.cnblogs.com/netfocus/p/5548025.html](https://www.cnblogs.com/netfocus/p/5548025.html)

[驱动领域DDD的微服务设计和开发实战](https://www.cnblogs.com/burningmyself/p/12116388.html)

