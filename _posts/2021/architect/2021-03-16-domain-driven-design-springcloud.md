---
layout: post
title: DDD领域驱动如何将业务拆分成微服务
category: architect
tags: [architect]
keywords: architect,springcloud
excerpt: DDD分层微服务，项目实战
lock: noneed
---

## 1、领域驱动设计

Domain Driven Design 领域驱动设计，简称DDD，就是基于模型驱动开发的设计思想。

domain 就是实体类或者PO持久化对象，也称模型，通常对应数据库表。domain就是数据模型，领域就是问题域，系统要解决的问题就是核心业务。

### 术语

- 事件风暴 Event Storm，指团队一起划分聚合以及限界上下文
- 实体 Entity，就是持久化对象，对应数据表，每个实体都有一个id唯一标识，如一件商品
- 值对象 Value Object，
- 聚合 Aggregate, 是业务和逻辑紧密关联的实体和值对象组合而成。聚合是领域的构成部分，聚合包含的实体和值对象就是领域对象。
- 聚合根，一个聚合中被其他实体围绕的实体，通常是业务的核心
- 限界上下文 Bounded Context ，聚合的边界
- 领域服务 Service，领域的构成部分，基于业务逻辑，对一个或多个实体的方法进行组合封装，对外暴露成服务。
- 领域事件 Event，位于Application应用层，就是对微服务
- 贫血模型，定义对象的简单属性值，没有业务逻辑上的方法，通常指值对象VO，属性值也可以称为状态
- 充血模型，定义对象的属性(状态)和行为（方法），行为是有业务意义的，通常指BO，有业务行为的对象。

### 聚合根

如果把聚合比作组织，聚合根则是组织的负责人，也叫根实体，是聚合的管理者。聚合是业务和逻辑紧密关联的实体和值对象组合而成

每个<mark>实体</mark>，具备自己的业务属性，<mark>业务行为</mark>，业务逻辑。

在聚合内部，聚合根负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑；

在聚合之间，聚合根是聚合对外的接口人，以聚合根ID的方式接受外部请求和任务，实现上下文中的聚合之间的业务协同。如果需要访问其他聚合的实体，先访问聚合根，再导航到聚合内部的实体。即外部对象不能直接访问聚合内的实体。

### 聚合

聚合是业务和逻辑紧密关联的实体和值对象组合而成，DDD的分层结构聚合位于领域层。领域层包含多个聚合，共同实现核心业务逻辑，聚合内的实体以充血模型实现个体业务能力。

业务逻辑的跨域场景：

- 需要一个聚合中的A实体和B实体共同完成，业务逻辑用领域服务来实现
- 需要聚合C和聚合D共同完成，应用服务组合连个聚合的领域服务

> 保单系统聚合例子

![](D:\jacob\code\aikomj.github.io\assets\images\2021\springcloud\ddd-baodan-1.png)



**领域建模**

1. 划分好边界上下文
2. 在每个边界上下文中设计领域模型
3. 画出领域模型图，圈出每个模型中的聚合边界
4. 设计领域模型时，要考虑该领域模型是否满足业务规则，同时还要综合考虑技术实现等问题，比如并发问题；领域模型不是概念模型，概念模型不关注技术实现，领域模型关心；所以领域模型才能直接指导编码实现；
5. 思考领域模型是如何在业务场景中发挥作用的，以及是如何参与到业务流程的每个环节的
6. 场景走查，确认领域模型是否能满足领域中的业务场景和业务流程；
7. 模型持续重构、完善、精炼；

一个普通电商系统的商品中心的领域模型图，给大家参考：

![](\assets\images\2021\springcloud\domain-product-model.bmp)



## 2、拆分成微服务

### DDD分层架构模型

![](\assets\images\2021\springcloud\ddd-structure.jpg)

- 展示层

  展现层负责向用户显示信息和解释用户指令，对接微服务的用户接口层

- 应用层

  尽量简单，它协调和指挥领域层的领域对象来完成业务逻辑，本身不包含业务规则。提供与业务无关的服务，如安全认证、权限校验、分布式和持久化事务控制或向外部应用发送基于事件的消息等。

- 领域层

  整个服务的核心所在，实现全部业务逻辑。它包含领域对象（实体、值对象）、领域服务。<mark>它负责表达业务概念、业务状态以及业务规则，具体表现形式就是领域模型。</mark>领域模型=领域对象+领域服务。包含了多个聚合，共同实现核心业务逻辑

- 基础设施层

  为各层提供通用的技术能力，包括：为应用层传递消息、提供 API 管理，为领域层提供数据库持久化机制等。它还能通过技术框架来支持各层之间的交互。

### 服务视图

一个微服务内有 Facade 接口（web接口）、应用服务、领域服务和基础服务，各层服务协同配合，为外部提供服务。如下图：

![](\assets\images\2021\springcloud\ddd-service-lay.jpg)

1. 接口服务(web接口)

   位于Interfaces用户接口层，处理用户发送的 Restful 请求和解析用户输入的配置文件等，并将信息传递给应用层。

2. 应用服务

   位于Application应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。  

   这里的服务包括**应用服务**和**领域事件服务**。

   a) **应用服务**可<mark>对微服务内的领域服务以及微服务外的应用服务（Feign方式调用）进行组合和编排</mark>，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务， 本身不包含业务逻辑，对业务用例的执行结果拼装。

   b) **领域事件服务**包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。

3. 领域服务

   位于Domain领域层，为完成领域中跨实体或值对象的操作转换而封装的服务。

   领域服务就是对<mark>一个聚合内</mark>的同一个实体或多个实体的操作进行组合封装，对外暴露成服务，这些服务封装了核心的业务逻辑。

   实体自身的行为在实体类内部实现，向上封装成领域服务暴露。

    为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。 为实现微服务内聚合之间的解耦，原则上<mark>禁止跨聚合的领域服务调用和跨聚合的数据相互关联</mark>。

   领域包含多个聚合，聚合由业务逻辑紧密关系的实体和值对象组合成。

4. 基础服务

   唯一Infrastructure基础层，为应用层和领域层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。 

   基础服务主要为仓储服务，通过依赖反转的方式(从容器中加载bean)为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象（DAO层）或直接访问基础资源。

> 微服务外的应用服务视图

主要有两个：

- 前端应用

  微服务中的应用服务通过用户接口层组装和数据转换后，发布在 API 网关，为前端应用提供数据展示服务。

- 外部应用

  当我们需要跨微服务数据处理时，通常会有两个场景

  1) 对实时性要求的场景，选择直接调用应用服务的方式，如果是新增修改的服务，因为是跨微服务会产生分布式事务，为保证数据的<mark>强一致性</mark>，需要整合<mark>分布式事务框架</mark>。

  2) 对实时性要求不高的场景，选择异步化的领域事件驱动机制，通过<mark>消息队列实现异步数据传输，实现最终一致性</mark>

### 数据视图

DDD 分层架构中数据对象转换的过程如下图。

![](D:\jacob\code\aikomj.github.io\assets\images\2021\springcloud\ddd-dto.png)

- 前端应用与用户接口层的DTO 与 VO 通过 Restful 协议实现 JSON 格式和对象转换。
- 微服务内应用服务需调用外部微服务的应用服务，则 DTO 的组装、 DTO 与 DO 的转换发生在应用层
- 领域层通过领域对象（DO）作为领域实体和值对象的数据和行为载体。

- 领域层 DO 与 PO 的转换发生在基础层，基础层则利用持久化对象（PO）完成数据库的交换。

### 领域事件

领域事件主要用于解耦微服务，微服务之间不再是强一致性，而是基于事件的最终一致性、弱一致性。领域事件的发布和订阅形成业务的闭环，如下图

![](D:\jacob\code\aikomj.github.io\assets\images\2021\springcloud\ddd-domain-event.jpg)

- **微服务内的领域事件**

  一个事件如果同时更新多个聚合数据，按照 DDD“一个事务只更新一个聚合根”的原则，可以考虑引入消息中间件，通过异步化的方式，对微服务内不同的聚合根采用不同的事务。

- **微服务之间的领域事件**

  微服务之间的数据交互方式通常有两种：

  1) 领域事件驱动机制

  用于实时性要求不高的业务场景，实现微服务之间的解耦，事件库（表）可以用于微服务之间的数据对账，在应用、网络等出现问题后，可以实现源和目的端的数据比对，在数据暂时不一致的情况下仍可根据这些数据完成后续业务处理流程，保证微服务之间数据的最终一致性。

  2) 应用服务调用

  用于实时性要求高的业务场景，一旦涉及到跨微服务的数据修改，将会增加分布式事务控制成本，影响系统性能，微服务之间的耦合度也会变高

- **事件总线**

  位于基础层，为应用层和领域层服务提供事件消息接收和分发等服务

  其大致流程如下： 服务触发并发布事件->事件总线事件分发。

  1) 如果是微服务内的订阅者（微服务内的其它聚合），则直接分发到指定订阅者

  2) 如果是微服务外的订阅者，则事件消息先保存到事件库（表）并异步发送到消息中间件。

  3) 如果同时存在微服务内和外订阅者，则分发到内部订阅者，并将事件消息保存到事件库（表）并异步发送到消息中间件。为了保证事务的一致性，事件表可以共享业务数据库。也可以采用多个微服务共享事件库的方式。当业务操作和事件发布操作跨数据库时，须保证业务操作和事件发布操作数据的强一致性。

- **事件数据持久化**

  可以有两种方案

  1) 事件数据保存到微服务所在业务数据库的事件表中，利用本地事务保证业务操作和事件发布操作的强一致性。

  2) 事件数据保存到多个微服务共享的事件库中。需要注意的一点是：这时业务操作和事件发布操作会跨数据库操作，须保证事务的强一致性（如分布式事务机制

  事件数据的持久化可以保证数据的完整性，基于这些数据可以完成跨微服务数据的一致性比对。

### 微服务设计方法





### 目录分层

基于DDD的一个微服务目录结构一般分4层，如下

![](\assets\images\2021\springcloud\domain-driven-design-1.jpg)

> 1) Interfaces用户接口层

相当于web的controller控制层，接受Request请求，将数据传递给Application层。

**子目录包括：**

- assembler，实现 dto 与领域对象(实体和值对象)之间的相互转换和数据交换
- dto 数据传输对象，内部不存在任何业务逻辑，dto让领域对象与外界隔离
- facade 门面模式，对外提供统一的调用接口，将用户请求委派给一个或多个Service应用服务进行处理

> 2) Application应用层

相对于web的Service层，主要代码形态是应用服务和领域事件等。

**子目录包括：**

- Event 事件，包括两种类型 publish发布 和 subscribe订阅,
- Service 应用服务，对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。

> 3) Domain领域层

主要实现核心领域逻辑，其主要代码形态是实体类方法和领域服务。

子目录包括：

- aggregate 聚合，聚合代码包的根目录，实际项目中以实际业务属性的名称来命名

- entity 实体，存放实体（含聚合根、实体和值对象）相关代码
- serivce 领域服务，根据业务逻辑对多个实体的操作进行组合编排封装，对外保留的服务
- repository 仓储，存放聚合对应的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定一个原则：一个聚合对应一个仓储。

> 4) Infrastructure基础层 [ˈɪnfrəstrʌktʃər]



一个微服务的总目录结构如下图：

![](\assets\images\2021\springcloud\ddd-fold-structure.jpg)

### 项目实战





**参考**

[https://www.cnblogs.com/netfocus/p/5548025.html](https://www.cnblogs.com/netfocus/p/5548025.html)

[驱动领域DDD的微服务设计和开发实战](https://www.cnblogs.com/burningmyself/p/12116388.html)

[聚合和聚合根](https://www.cnblogs.com/snidget/p/13061233.html)