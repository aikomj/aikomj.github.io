---
layout: post
title: Go全栈第11节：Go I/O流
category: go
tags: ['base']
keywords: go
excerpt: input输入流与output输出流，os包中的file接口,Stat获取文件信息，文件权限科普，Mkdir创建目录，Create创建文件，Remove删除目录与文件，Openfile打开文件，File.Read方法读取文件内容
lock: noneed
---

## 1、FileInfo获取文件信息

file类是在os包中，封装了底层的文件描述符和相关信息，同时封装了Read和Write实现

FileInfo接口中定义了file信息相关的方法

```go
type FileInfo interface {
  Name() string // 文件名.扩展名
  Size() int64 // 文件大小，字节数
  Mode() FileMode // 文件权限，-rw-rw-rw-，类似linux的文件权限
  ModTime time.Time // 修改时间
  isDir() bool // 是否文件夹
}
```

> Stat方法获取文件信息

```go
import (
	"fmt"
	"os"
)

func main() {
	// os包下获取文件信息
	fileInfo, err := os.Stat("/Users/xjw/GoWorks/src/awesomeProject/lesson11/a.txt") // 当前目录下a.txt文件
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(fileInfo.Name())
	fmt.Println(fileInfo.IsDir()) // 是否一个目录
	fmt.Println(fileInfo.Size())  // 文件大小
	fmt.Println(fileInfo.Mode())   // 文件权限
	fmt.Println(fileInfo.ModTime()) // 修改时间

	// 反射获取文件更加详细的信息
	fmt.Println(fileInfo.Sys())
}
```

执行结果：

```sh
a.txt
false
12
-rw-r--r--
2023-01-17 23:07:42.795522552 +0800 CST
&{16777220 33188 1 45976985 501 20 0 [0 0 0 0] {1673968036 291220116} {1673968062 795522552} {1673968062 795522552} {1673968036 291220116} 12 8 4096 0 0 0 [0 0]}
```

文件权限科普

> linux下有两种文件权限表示方式：符号和八进制

```sh
1、符号表示
-     rwx     ---     ---
type  owner   group   others

type 文件类型，-代表文件，d代表目录 | 连接符号
---代表的文件读写可执行，字母rwx,如果没有那个权限就用 - 代替

2、八进制表示
r  004
w  002
x  001
-  000

chmod 777 授权ower group others可读可写可执行
```

授权脚本

## 2、创建目录与文件

> 创建目录 Mkdir，MkdirAll，Remove，

```go
func main() {
	err := os.Mkdir("/Users/xjw/GoWorks/src/awesomeProject/lesson11/test", os.ModeDir)
	if err != nil {
		fmt.Println(err)
	}
	// 创建层级文件夹
	err = os.MkdirAll("/Users/xjw/GoWorks/src/awesomeProject/lesson11/test2/a/b", os.ModeDir)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("文件夹创建成功")

	// 删除文件夹或文件
	// RemoveAll 谨慎使用
	err = os.Remove("/Users/xjw/GoWorks/src/awesomeProject/lesson11/test2")
	if err != nil {
		fmt.Println(err)
	}
}
```

> 创建文件 Create

```go
func main() {
	// 创建文件
	// 返回文件指针，与err变量,如果原文件存在，会把文件内容清空，并重新创建
	file, err := os.Create("./b.txt")
	fmt.Println(file.Name())
	fmt.Println(err)

	os.Remove("./b.txt") // 可以是相对路径或绝对路径
}
```

## 3、读取文件内容

> OpenFile (文件路径名称，文件打开方式，文件权限)打开文件，要记得使用defer关闭文件
>
> Read 读取文件

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 获取文件信息
	fileinfo, err := os.Stat("b.txt")
	fmt.Println(fileinfo.Mode()) // 文件的权限

	// Open打开文件
	// 1、打开文件，建立连接
	// 返回文件指针与error变量
	file, err := os.Open("./b.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(file.Name())
	// 2、关闭文件，使用defer延迟执行关键字，压栈延迟执行
	defer file.Close()

	// 读取文件内容
	// 创建切片来接收内容（缓冲区大小与读取文件）
	bs := make([]byte, 1024, 1024) // byte类型，长度为1024，容量1024）
	// Read到容器，返回读取的数量n, 与 err变量，后续可以使用for循环判断n>0读取文件的所有内容
  // 直到返回n==0,光标移动到了文件的末尾，同时返回err=io.EOF
	// 如果读到文件的末尾，err = io.EOF
	n, err := file.Read(bs)
	fmt.Println(n)
	fmt.Println(string(bs))
	fmt.Println(err)
	n, err = file.Read(bs)
	fmt.Println(n)
	fmt.Println(string(bs))
	fmt.Println(err)

	// OpenFile (文件路径名称，文件打开方式，文件权限) 返回文件指针与error变量
	file2, err := os.OpenFile("b.txt", os.O_RDONLY|os.O_WRONLY, os.ModePerm)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(file2.Name())
	defer file2.Close()
}
```

执行结果：

```sh
-rw-r--r--
./b.txt
12
钱兔无量
<nil>
0
钱兔无量
EOF
b.txt

```



查看file.Read方法源码

```go
// Read reads up to len(b) bytes from the File and stores them in b.
// It returns the number of bytes read and any error encountered.
// At end of file, Read returns 0, io.EOF.
func (f *File) Read(b []byte) (n int, err error) {
	if err := f.checkValid("read"); err != nil {
		return 0, err
	}
	n, e := f.read(b)
	return n, f.wrapErr("read", e)
}
```





## 4、写入文件内容









