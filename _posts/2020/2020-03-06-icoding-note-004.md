---
layout: post
title: 飞天班第4节：JUC并发编程2
category: icoding-edu
tags: [icoding-edu]
keywords: icoding
excerpt: 读写锁、阻塞队列、同步队列、线程池、函数式接口和stream流式计算、任务分支合并forkjoin、异步回调
lock: noneed
---

## 0.费曼学习法

​	费曼学习法，由理查德费曼(1918-1988年)提出，美籍犹太人，诺贝尔得主，著名的教育家，1965年获的诺贝尔物理学奖。

![](/assets/images/2020/feiman.jpeg)

**具体来说，费曼学习法分为4个步骤：**

第1步：确定学习目标。

你想学习的概念、内容、主题是什么。

第2步：模拟教学学习法。

你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。

第3步：回顾。

反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。

第4步：简化。

把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。

其实，我们每天都或多或少地需要向别人讲诉自己的想法和观点，并希望达成他人能够听懂理解的意图。但是，费曼学习法最巧妙的地方就在于它深度地解构了这种过程，并且把它当成一种学习方法。

## 1.读写锁

独占锁（写锁）：一次只能被一个线程占有
共享锁（读锁）：该锁可以被多个线程占有

还是java.util.concurrent包中类

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
	public static void main(String[] args) {
		final MyCacheLock myCache = new MyCacheLock();
		// 模拟线程
		// 写
		for (int i = 0; i <=5; i++) {
			final int tempInt = i;
			new Thread(()->{
				myCache.put(tempInt +"",tempInt+"");
			}).start();
		}

		// 读
		for (int i = 0; i <=5; i++) {
			final int tempInt = i;
			new Thread(()->{
				myCache.get(tempInt+"");
			}).start();
		}
	}
}

// 资源类，读写
class MyCacheLock{
	// volatile 保证变量的可见性，线程对变量的修改对所有线程来说都是可见的，变量值的存取一定是
	// 在共享内存中进行的。
	private volatile Map<String,Object> map = new HashMap<String, Object>();

	private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

	// 读 可以被多个线程同时读
	public void get(String key){
		// 锁一定要匹配，否则可能导致死锁
		readWriteLock.readLock().lock();
		try {
			System.out.println(Thread.currentThread().getName()+"读取" + key);
			Object o = map.get(key);
			System.out.println(Thread.currentThread().getName()+"读取结果："+o);
		}catch (Exception e){
			e.printStackTrace();
		}finally {
			readWriteLock.readLock().unlock();
		}
	}

	// 写，保证原子性
	public void put(String key,Object value){
		readWriteLock.writeLock().lock();
		try {			System.out.println(Thread.currentThread().getName()+"写入"+key);
			map.put(key,value);	System.out.println(Thread.currentThread().getName()+"写入完成");
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			readWriteLock.writeLock().unlock();
		}
	}
}
```

## 2.阻塞队列BlockingQueue

1. 为什么要用阻塞队列

   <font color="red">在写多线程序的时候，如果不想通过唤醒的方式实现线程间的通信，可以使用阻塞队列解决。</font>

   - 使用场景生产者和消费者模型

     生产者生产数据，放入队列，然后消费者从队列中获取数据，这个在一般情况下自然没有问题，但出现消费者速度远大于生产者速度，消费者在数据消费至一定程度的情况下，可以阻塞消费者来等待生产者，以保证生产者能够生产出新的数据；反之亦然

   - 使用场景线程池，在线程池中，当提交的任务不能被立即得到执行的时候，线程池就会将提交的任务放到一个阻塞的任务队列中来

   > 扩展阅读：https://www.cnblogs.com/NathanYang/p/11276428.html

2. 什么情况队列会阻塞
   - 当队列是满的，你还要添加元素就会被阻塞；
   - 当队列是空的，你还要取元素就会被阻塞；

3. Collection家族

   ​	![](/assets/images/2020/collection-children.png)

**四组API**

| 方法 | 会抛异常  | 返回布尔值，不抛异常 | 延时等待       | 一直等 |
| ---- | --------- | -------------------- | -------------- | ------ |
| 插入 | add(e)    | offer(e)             | offer(e, time) | put(e) |
| 取值 | remove()  | poll()               | poll(time)     | take() |
| 检查 | element() | peek()               |                |        |

建议add与remove一组，offer与poll一组

```java
public class BlockingQueueDemo {
	public static void main(String[] args) throws InterruptedException {
		ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3);
		blockingQueue.add("a");
		blockingQueue.add("b");
		blockingQueue.add("c");
		//blockingQueue.add("d"); // 队列满了，会抛异常
		//System.out.println(blockingQueue.element());   // 返回第一个元素，没有会抛异常
		System.out.println(blockingQueue.peek());   // 返回第一个元素,没有返回null,不抛异常

		// offer与poll
		System.out.println(blockingQueue.offer("a"));
		System.out.println(blockingQueue.offer("b"));
		System.out.println(blockingQueue.offer("c"));
		System.out.println(blockingQueue.offer("d",3, TimeUnit.SECONDS));  //尝试等待3秒，失败返回false
		System.out.println(blockingQueue.poll());
		System.out.println(blockingQueue.poll());
		System.out.println(blockingQueue.poll());
		System.out.println(blockingQueue.poll(3,TimeUnit.SECONDS)); //尝试等待3秒，没有值返回null

		// put与take
		blockingQueue.put("a");
		blockingQueue.put("b");
		blockingQueue.put("c");
		blockingQueue.put("d"); // 队列满了，一直等，并且会阻塞

		System.out.println(blockingQueue.take());
		System.out.println(blockingQueue.take());
		System.out.println(blockingQueue.take());
		System.out.println(blockingQueue.take()); // 队列空了，一直等，并且会阻塞
	}
}
```

### 2.2 同步队列SynchronousQueue

SynchronousQueue是BlockingQueue下的一个实现类，它是没有容量的。

![](/assets/images/2020/synchronous-queue.png)

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class SynchronousQueueDemo {
	public static void main(String[] args) throws InterruptedException {
		// 同步队列
		BlockingQueue<String> blockingQueue = new SynchronousQueue<>();

		// A存
		new Thread(()->{
			try {
				System.out.println(Thread.currentThread().getName() +"put a");
				blockingQueue.put("a");
				System.out.println(Thread.currentThread().getName() +"put b");
				blockingQueue.put("b");
				System.out.println(Thread.currentThread().getName() +"put c");
				blockingQueue.put("c");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		},"A").start();

		// B取
		new Thread(()->{
			try {
				TimeUnit.SECONDS.sleep(3);
				System.out.println(Thread.currentThread().getName() + "take " +blockingQueue.take());

				TimeUnit.SECONDS.sleep(3);
				System.out.println(Thread.currentThread().getName() + "take " +blockingQueue.take());

				TimeUnit.SECONDS.sleep(3);
				System.out.println(Thread.currentThread().getName() + "take " +blockingQueue.take());

			} catch (InterruptedException e) {
				e.printStackTrace();
			}

		},"B").start();
	}
}
```

## 3.线程池

线程池的作用：线程复用，提高程序的使用率

![](/assets/images/2020/ali-threadPoolExecutor.png)

- 三大方法

  ```java
  public class ThreadPoolDemo {
  	public static void main(String[] args) {
  		// 单例，只有一个线程
  		//ExecutorService threadPool = Executors.newSingleThreadExecutor();
  		// 固定的线程数
  		//ExecutorService threadPool = Executors.newFixedThreadPool(6);
  		// 可伸缩容量的线程池
  		//ExecutorService threadPool = Executors.newCachedThreadPool();
  
      // 根据阿里巴巴开发手册，直接使用ThreadPoolExecuto创建线程池，看下面七大参数的含义，与4种拒绝执行任务的策略
  ExecutorService threadPool = new ThreadPoolExecutor(2,5,3, TimeUnit.SECONDS
  				,new LinkedBlockingDeque<>(3),new ThreadPoolExecutor.AbortPolicy()); 
      
  		// 使用线程池
  		try {
  			for (int i = 0; i < 20; i++) {
  				threadPool.execute(()->{
  					System.out.println(Thread.currentThread().getName() + " ok");
  				});
  			}
  		} catch (Exception e) {
  			e.printStackTrace();
  		} finally {
  			// 关闭线程池
  			threadPool.shutdown();
  		}
  	}
  }
  ```

- 七大参数：

  查看源码三大方法都是使用ThreadPoolExecuto创建的

  ```java
    public static ExecutorService newCachedThreadPool() {
          return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                        60L, TimeUnit.SECONDS,
                                        new SynchronousQueue<Runnable>());
      }
  
  // 七大参数
  public ThreadPoolExecutor(int corePoolSize, // 核心池线程数大小 (常用)
                                int maximumPoolSize,  // 最大线程数大小 (常用)
                                long keepAliveTime, // 超时时间 (常用)
                                TimeUnit unit, // 时间单位 (常用)
                                BlockingQueue<Runnable> workQueue, // 阻塞队列(常用)
                                ThreadFactory threadFactory, // 线程工厂
                                RejectedExecutionHandler handler // 拒绝策略(常用)) {
                            ....
  }      
  ```

  ![](/assets/images/2020/threadPoolExecutor.png)

- 4种拒绝策略

> 1.ThreadPoolExecutor.AbortPolicy()；  抛出异常，丢弃任务
> 2.ThreadPoolExecutor.DiscardPolicy()；不抛出异常，丢弃任务
> 3.ThreadPoolExecutor.DiscardOldestPolicy()； 尝试获取任务，不一定执行！
> 4.ThreadPoolExecutor.CallerRunsPolicy();	找调用方的线程去执行任务，如上面的代码是main函数调用线程池执行任务的，则线程池满了后会找main线程执行任务，看下面结果:
>
> ![](/assets/images/2020/threadPoolExecutor-callRunPolicy.png)

> 终极问题：最大线程池（）该如何设置？

- CPU密集型：根据CPU的处理器数量来定，保证最大效率

  ```java
  // Returns the number of processors available to the Java virtual machine
  // 获取jvm可用的cpu处理器数量
  System.out.println(Runtime.getRuntime().availableProcessors());
  ```

- **IO密集型：** 50 个线程都是进程操作大io资源, 比较耗时！ > 这个常用的 IO 任务数！

  

## 4.函数式接口

在Java.util.function包下，核心的有4个接口：Consumer 、Function、Supplier、Predicate

<font color="red">函数式接口使用lambda表达式简化</font>

- Function：有一个输入参数，一个输出参数

  ```java
  public static void main(String[] args) {
  		Function<String,Integer> function = (str)->{
  			return str.length();
  		};
  		System.out.println(function.apply("helloworld"));
  }
  ```

- Consumer：有一个输入参数，没有输出参数

- Supplier：没有输入参数，有一个输出参数

  ```java
  public static void main(String[] args) {
  		Supplier<String> supplier = ()->{
  			return "hello,spring";
  		};
  
  		Consumer<String> consumer =(str)->{
  			System.out.println(str);
  		};
  		consumer.accept(supplier.get());
  	}
  ```

- Predicate：有一个输入参数，返回boolean，判断是否正确

  ```java
  		Predicate<String> predicate1 = (str)->{
  			return str.equals("123");
  		};
  		Predicate<String> predicate2 = (str)->{
  			return str.equals("456");
  		};
  
  		System.out.println(predicate1.test("123"));
  		System.out.println(predicate1.and(predicate2).test("123"));
  ```



## 5.Stream流式计算

在java.util.stream包下，基于函数式接口实现的流式计算，

```java
import java.util.Arrays;
import java.util.List;

/**
 * 按条件筛选用户
 * 1.id 为偶数
 * 2.年龄大于22
 * 3.用户名大写
 * 4.用户名倒排序
 * 5.输出一个用户
 * 用一行代码完成
 */
public class StreamDemo {
	public static void main(String[] args) {
		User user1 = new User(1L,"a",23);
		User user2 = new User(2L,"b",24);
		User user3 = new User(3L,"c",22);
		User user4 = new User(4L,"d",28);
		User user5 = new User(5L,"e",26);

		List<User> userList = Arrays.asList(user1,user2,user3,user4,user5);

		userList.stream()
				.filter(user->{return user.getId() %2 ==0;})
				.filter(user->{return user.getAge()>22;})
				.map(user->{return user.getName().toUpperCase();})
				.sorted((a1,a2)->{return a2.compareTo(a1);})
				.limit(1)
				.forEach(System.out::println);
	}
}
```

## 12.分支合并forkjoin

两步：

1. 任务拆分
2. 结果合并

主要实现类java.util.concurrent.ForkJoinPool

![](/assets/images/2020/juc-forkjoin.png)