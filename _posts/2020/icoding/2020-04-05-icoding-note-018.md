---
layout: post
title: 飞天班第18节：企业项目研发（二）后端微服务搭建
category: icoding-edu
tags: [icoding-edu]
keywords: springboot
excerpt: MP代码生成器，所有基本CRUD业务代码一键生成，标准微服务项目架构搭建，统一返回结果，统一异常处理，统一日志处理
lock: noneed
---



## 1、MP代码生成工具

导入依赖

```xml
<!-- mybatis-plus -->
<dependency>
  <groupId>com.baomidou</groupId>
  <artifactId>mybatis-plus-boot-starter</artifactId>
  <version>3.0.5</version>
</dependency>
<dependency>
  <groupId>org.apache.velocity</groupId>
  <artifactId>velocity-engine-core</artifactId>
  <version>2.0</version>
</dependency>
```

参考官网教程：[https://mp.baomidou.com/guide/generator.html#%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B](https://mp.baomidou.com/guide/generator.html#%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B)

编写自己的代码生成类CodeGenerator



## 2、实战项目

### 项目分析

实战项目icoding-edu，是一个B2C模式的职业技能在线教育系统，分为前台用户系统和后台运营平台。

- 前台系统包括课程、问答、文章三大部分。

- 后台运营平台包括会员管理、讲师管理、课程管理、文章资讯、统计分析等。

> 技术栈

使用前后端分离架构。

- 前端：Node.js+Vue.js+Nuxt

- 后端：SpringBoot+SpringCloud+Mybatis-Plus+Mysql+Swagger2

  使用阿里云OSS、阿里云视频点播、微信登录、ECharts图表展示，POI解析Excel。

> 系统模块

![](/assets/images/2020/icoding/icoding-edu-module.gif)

> 系统架构

![](/assets/images/2020/icoding/icoding-edu-arch.gif)



### 项目微服务搭建

  1.首先要设计好数据库表

![](/assets/images/2020/icoding/icoding-edu-table.gif)

  2.接着搭建基本的微服务架构

![](/assets/images/2020/icoding/icoding-edu-project.gif)

edu-parent是父依赖，只做依赖包版本管理。

```xml
<!-- 控制我们整个项目的所有的依赖！ -->
<parent>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-parent</artifactId>
  <version>2.2.5.RELEASE</version>
  <relativePath/>
</parent>
<groupId>com.coding</groupId>
<artifactId>coding-edu-parent</artifactId>
<!-- 打包方式是pom文件！ -->
<packaging>pom</packaging>
<properties>
  <java.version>1.8</java.version>
  <!-- 我们要使用的扩展的版本控制中心都在这里进行配置 -->
  <coding.version>0.0.1-SNAPSHOT</coding.version>
  <mybatis-plus.version>3.0.5</mybatis-plus.version>
  ...
</properties>
 <!-- dependencyManagement 只是管理并不会真正的下载！-->
<dependencyManagement>
  <dependencies>
    <!--公共业务模块版本管理-->
    <dependency>
      <groupId>com.coding</groupId>
      <artifactId>coding-edu-common</artifactId>
      <version>${coding.version}</version>
    </dependency>

    <!--mybatis-plus 持久层-->
    <dependency>
      <groupId>com.baomidou</groupId>
      <artifactId>mybatis-plus-boot-starter</artifactId>
      <version>${mybatis-plus.version}</version>
    </dependency>
   .....
<dependencyManagement>    
```

edu-commom是公共模块，所有的基本业务都依赖该模块

```xml
<!-- 父依赖 -->
<parent>
  <artifactId>coding-edu-parent</artifactId>
  <groupId>com.coding</groupId>
  <version>0.0.1-SNAPSHOT</version>
  <relativePath>../coding-edu-parent/pom.xml</relativePath>
</parent>
```

edu-edu是edu业务模块

<b style="color:red">这里的edu就是我们对应 coding_edu 这个数据库的，一个微服务对应一个数据库</b>

```xml
<!-- 父依赖 -->
<parent>
  <artifactId>coding-edu-parent</artifactId>
  <groupId>com.coding</groupId>
  <version>0.0.1-SNAPSHOT</version>
  <relativePath>../coding-edu-parent/pom.xml</relativePath>
</parent>
...
<dependencies>
    <!-- 依赖公共模块 -->
    <dependency>
      <groupId>com.coding</groupId>
      <artifactId>coding-edu-common</artifactId>
    </dependency>
</dependencies>s  
```

3.edu-edu模块使用MP代码生成工具，连接数据库 coding_edu,生成CRUD业务代码

```java
public class CodeGenerator {
    // 自动生成代码
    public static void main(String[] args) {

      // 模块名
      String moduleName = "edu";

      ....
      // 乐观锁
      strategy.setVersionFieldName("version");
      strategy.setRestControllerStyle(true); // restful api
      strategy.setControllerMappingHyphenStyle(true); //  /user/hello_name 使用_连接驼峰！

        mpg.setStrategy(strategy);
      
        // 2、执行代码生成器
        mpg.execute();

    }
}
```



代码生成器里我们设置了去掉is_前缀

```java
strategy.setLogicDeleteFieldName("is_delete");  // 逻辑删除字段
strategy.setEntityBooleanColumnRemoveIsPrefix(true); // 去掉布尔值的列的is_前缀
```

导致属性名与列名不一致，需要指定列名

```java
public class Teacher implements Serializable {
	...
    @ApiModelProperty(value = "逻辑删除 1（true）已删除， 0（false）未删除")
    @TableField(value = "is_deleted")
    @TableLogic
    private Boolean deleted;
  ...
}
```



4.配置Swagger

   ```java
   @Configuration
   @EnableSwagger2
   public class Swagger2Config {
       @Bean
       public Docket webApiConfig(){
           //过滤掉 admin 下的请求
           return new Docket(DocumentationType.SWAGGER_2)
                   .groupName("webApi")
                   .apiInfo(webApiInfo())
                   .select()
                   .paths(Predicates.not(PathSelectors.regex("/admin/.*")))
                   .paths(Predicates.not(PathSelectors.regex("/error.*")))
                   .build();
       }
   
       @Bean
       public Docket adminApiConfig(){
           //只选取 /admin 下的请求
           return new Docket(DocumentationType.SWAGGER_2)
                   .groupName("adminApi")
                   .apiInfo(adminApiInfo())
                   .select()
                   .paths(Predicates.and(PathSelectors.regex("/admin/.*")))
                   .build();
       }
   
       private ApiInfo webApiInfo(){
           return new ApiInfoBuilder()
                   .title("网站-课程中心API文档")
                   .description("本文档描述了课程中心微服务接口定义")
                   .version("1.0")
                   .contact(new Contact("Coding", "http://icodingedu.com", "24736743@qq.com"))
                   .build();
       }
   
       private ApiInfo adminApiInfo(){
           return new ApiInfoBuilder()
                   .title("后台管理系统-课程中心API文档")
                   .description("本文档描述了后台管理系统课程中心微服务接口定义")
                   .version("1.0")
                   .contact(new Contact("Coding", "http://icodingedu.com", "24736743@qq.com"))
                   .build();
       }
   }
   ```



### 统一返回结果

真正的微服务项目是提供给多端使用的，web\app\小程序，所以需要返回的数据格式是统一的。

我们的系统要求返回的基本数据格式如下：

- 列表

  ```json
  {
    "success": true,
    "code": 20000,
    "message":"成功",
    "data":{
      "item":[
        {
          "id":1,
          "name": "coding"
        }
        ...
      ]
    }
  }
  ```

- 分页

  ```json
  {
    "success":true,
    "code": 20000,
    "message":"成功",
     "data":{
       "total":17,
       "rows":[
         ....
       ]
     }
  }
  ```

- 没有返回数据

  ```json
  {
    "success":true,
    "code":20000,
    "message":"成功",
    "data":{}
  }
  ```

- 失败

  ```json
  {
    "success": false,
    "code": 20001,
    "message": "失败",
    "data":{}
  }
  ```

因此，我们定义统一返回结果

```json
{
  "success": 布尔,	// 是否成功
  "code": 数字,	// 响应码
  "message": 字符串,// 返回消息
  "data": HashMap //返回数据，键值对
}
```

> 使用枚举定义不同的返回码

```java
package com.coding.common.constants;

import lombok.Getter;

@Getter
public enum ResultCodeEnum {
    // 未来在这里会有十分多的状态码！
    SUCCESS(true,20000,"成功"),
    UNKNOW_REASON(false,20001,"未知错误"),
    BAD_SQL_GRAMMAR(false,21001,"sql语法错误"),
    JSON_PARSE_ERROR(false,21002,"json 解析错误"),
    PARAM_ERROR(false,21003,"参数不正确");

    private Boolean success; // 是否响应成功
    private Integer code;    // 响应的状态码
    private String message;  // 响应的消息

    ResultCodeEnum(Boolean success, Integer code, String message) {
        this.success = success;
        this.code = code;
        this.message = message;
    }
}
```

> 统一返回结果类

```java
// 无论什么接口，返回值永远是R！
@Data
@ApiModel(value = "全局的统一返回结果")
public class R {

    @ApiModelProperty(value = "是否成功")
    private Boolean success;
    @ApiModelProperty(value = "返回状态码")
    private Integer code;
    @ApiModelProperty(value = "返回消息")
    private String message;
    @ApiModelProperty(value = "返回的数据！")
    private Map<String,Object> data = new HashMap<>();

    public R() {
    }

    // ok
    public static R ok(){
        R r = new R();
        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());
        r.setCode(ResultCodeEnum.SUCCESS.getCode());
        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());
        return r;
    }

    // error
    public static R error(){
        R r = new R();
        r.setSuccess(ResultCodeEnum.UNKNOW_REASON.getSuccess());
        r.setCode(ResultCodeEnum.UNKNOW_REASON.getCode());
        r.setMessage(ResultCodeEnum.UNKNOW_REASON.getMessage());
        return r;
    }

    // setResult 自定义错误码！
    public static R setResult(ResultCodeEnum resultCodeEnum){
        R r = new R();
        r.setSuccess(resultCodeEnum.getSuccess());
        r.setCode(resultCodeEnum.getCode());
        r.setMessage(resultCodeEnum.getMessage());
        return r;
    }

    // 这些是为了我们方便链式编程
    public R success(Boolean success){
        this.setSuccess(success);
        return this;
    }
    public R message(String message){
        this.setMessage(message);
        return this;
    }
    public R code(Integer code){
        this.setCode(code);
        return this;
    }
    public R data(String key,Object value){
        this.data.put(key,value);
        return this;
    }

    public R data(Map<String,Object> map){
        this.setData(map);
        return this;
    }
}
```

测试接口返回结果

```java
@ApiOperation(value = "获取讲师列表")
@GetMapping
public R list(){
  List<Teacher> list = teacherService.list(null);
  return R.ok().data("items",list);
}

@ApiOperation(value = "根据id删除讲师")
@DeleteMapping("{id}")
public R removeById(
  @ApiParam(name = "id",value = "讲师id",required = true)
  @PathVariable String id){
  teacherService.removeById(id);
  return R.ok();
}
```



### 自动填充

实体类中我们都添加了gmtCreate,gmtModified，

```java
@ApiModelProperty(value = "创建时间",example = "2020-04-05 00:00:00")
@TableField(fill = FieldFill.INSERT)
private Date gmtCreate;

@ApiModelProperty(value = "更新时间")
@TableField(fill = FieldFill.INSERT_UPDATE)
private Date gmtModified;

```

插入和更新数据时要自动填充时间，新建一个MyMetaObjectHandler类放到edu-commom模块下

```java
// MetaObjectHandler 元对象处理
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {

    // 插入的策略
    @Override
    public void insertFill(MetaObject metaObject) {
        // this.setFieldValByName()设置当前字段的值！
        // String fieldName, Object fieldVal, MetaObject metaObject
        // 以后只要是插入操作就会自动控制
        // createTime updateTime 使用 new Date() 进行填充

        this.setFieldValByName("gmtCreate",new Date(),metaObject);
        this.setFieldValByName("gmtModified",new Date(),metaObject);
    }

    // 更新策略
    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("gmtModified",new Date(),metaObject);
    }
}
```

同时edu-edu模块的启动类需要增加扫描commom包

```java
@SpringBootApplication
@ComponentScan(basePackages = {"com.coding.edu","com.coding.common"})
public class EduApplication {
    public static void main(String[] args) {
        SpringApplication.run(EduApplication.class,args);
    }
}
```

