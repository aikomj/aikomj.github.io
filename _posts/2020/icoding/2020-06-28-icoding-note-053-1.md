---
layout: post
title: 飞天班第53节：数据切分设计方案Sharding-jdbc
category: icoding-edu
tags: [icoding-edu]
keywords: mysql
excerpt: 客户端代理模式数据源连接管理应用Sharingjdbc,引入使用，配置广播表，绑定表，读写分离
lock: noneed
---

## 1. Sharding-Jdbc介绍

官方文档：[https://shardingsphere.apache.org/](https://shardingsphere.apache.org/)

![](/assets/images/2020/icoding/mysql/sharding-sphere.jpg)

sharingSphere 包括，使用时一定要多看看用户手册

![](/assets/images/2020/icoding/mysql/sharding-sphere2.jpg)

Sharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。

- sharding-jdbc是一个分布式的关系型数据库中间件
- <font color=red>客户端代理模式，不需要搭建服务器，只需要后端数据库即可，有个IDE就行了</font>
- 定位于轻量级的Java框架，以jar的方式提供服务
- 可以理解为增强版的jdbc驱动
- 完全兼容主流的ORM框架，如Mybatis-plus
- 架构：

![](/assets/images/2020/icoding/mysql/sharding-jdbc.jpg)

- sharding-jdbc提供了4种配置
  - Java API
  - yaml (层级深)
  - properties
  - spring命名空间

- **与MyCat的区别**
  - <font color=red>MyCat是服务端的代理模式，Sharding-Jdbc是客户端代理模式</font>
  - 实际开发中如果企业有DBA建议使用MyCat，都是开发人员建议使用sharding-jdbc
  - MyCat不支持在一个库内进行水平分表，而sharding-jdbc支持在同一个数据库中进行水平分表
- 名词解释
  - 逻辑表：物理表的合并表
  - 真实表：存放数据的地方
  - 数据节点：存储数据的MySQL节点
  - 绑定表：相当于MyCat中的子表
  - 广播表：相当于MyCat中的全局表

## 2. Sharding-Jdbc引入使用

```shell
# 0.首先在两个MySQL实例上分别创建数据库：shard_order
# 1.在两个数据库创建两个表order_info_1,order_info_2
CREATE TABLE `order_info_1` (
  `id` int(11) NOT NULL,
  `order_amount` decimal(10,2) DEFAULT NULL,
  `order_status` int(255) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
CREATE TABLE `order_info_2` (
  `id` int(11) NOT NULL,
  `order_amount` decimal(10,2) DEFAULT NULL,
  `order_status` int(255) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
# 2.切分规则，按照id的奇偶数切分到两个数据库，在自己的数据库按照user_id进行表切分
```

![](/assets/images/2020/icoding/mysql/shard-order.jpg)

新建一个SpringBoot项目

代码导入POM依赖

```xml
<dependency>
  <groupId>org.apache.shardingsphere</groupId>
  <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
  <version>4.0.0-RC2</version>
</dependency>
```

applicaiton.properties配置

```shell
# 给两个数据源命名
spring.shardingsphere.datasource.names=ds0,ds1
# 数据源链接ds0要和命名一致
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds0.jdbcUrl=jdbc:mysql://39.103.163.215:3306/shard_order
spring.shardingsphere.datasource.ds0.username=gavin
spring.shardingsphere.datasource.ds0.password=123456
# 数据源链接ds1要和命名一致
spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds1.jdbcUrl=jdbc:mysql://39.101.221.95:3306/shard_order
spring.shardingsphere.datasource.ds1.username=gavin
spring.shardingsphere.datasource.ds1.password=123456
# 具体的分片规则,基于数据节点
spring.shardingsphere.sharding.tables.order_info.actual-data-nodes=ds$->{0..1}.order_info_$->{1..2}
# 分库的规则
spring.shardingsphere.sharding.tables.order_info.database-strategy.inline.sharding-column=id
spring.shardingsphere.sharding.tables.order_info.database-strategy.inline.algorithm-expression=ds$->{id % 2}
# 分表的规则
spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.sharding-column=user_id
spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.algorithm-expression=order_info_$->{user_id % 2 + 1}
```

```java
// 使用jdbcTemplate 测试代码
@SpringBootTest
class ShardingjdbcProjectApplicationTests {
    @Autowired
    JdbcTemplate jdbcTemplate;

    @Test
    void insertTest(){
        String sql = "insert into order_info(id,order_amount,order_status,user_id) values(3,213.88,1,2)";
        int i = jdbcTemplate.update(sql);
        System.out.println("影响行数:"+i);
    }
}
```

结合 mybatis-plus  ORM 框架 测试代码

> 插入数据

```java
@Autowired
OrderInfoService orderInfoService;

@Test
void contextLoads() {
		OrderInfo orderInfo = new OrderInfo();
		orderInfo.setId(2).setOrderAmount(BigDecimal.valueOf(300)).setOrderStatus(1).setUserId(1);
		orderInfoService.save(orderInfo);

		OrderInfo orderInfo2 = new OrderInfo();
		orderInfo2.setId(3).setOrderAmount(BigDecimal.valueOf(213)).setOrderStatus(1).setUserId(2);
		orderInfoService.save(orderInfo2);
}
```

报错，一个坑,

![](/assets/images/2020/icoding/mysql/shardingDataSource-jdbc.jpg)

```properties
spring.shardingsphere.datasource.ds0.url=jdbc:mysql://39.103.163.215:3306/shard_order
# 修改为：
spring.shardingsphere.datasource.ds0.jdbcUrl=jdbc:mysql://39.103.163.215:3306/shard_order
```

运行成功后，发现两张订单表已分库分表

![](/assets/images/2020/icoding/mysql/sharding-jdbc-213.jpg)

![](/assets/images/2020/icoding/mysql/sharding-jdbc-214.jpg)

> 查询所有数据

```java
// 使用上没有任何变化
@Test
void listAll() {
  List<OrderInfo> list = orderInfoService.list();
  list.forEach(System.out::println);
}
```

![](/assets/images/2020/icoding/mysql/sharding-jdbc-list-all.jpg)



## 3. 配置广播表

相当于mycat的全局表(每个库的数据一样，就是全部数据)，先在两个库上创建广播表province_info

应用场景：数据量不大，并且不希望数据分片的表，如配置表，省市区表

```sql
CREATE TABLE `province_info` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

在application.properties里增加配置

```shell
spring.shardingsphere.sharding.broadcast-tables=province_info
```

测试插入和查询的代码

```java
@Test
void insertBroadcast(){
  String sql = "insert into province_info(id,name) values(1,'beijing')";
  int i = jdbcTemplate.update(sql);
  System.out.println("******* 影响的结果："+i);
}

@Test
void selectBroadcast(){
  String sql = "select * from province_info";
  List<Map<String,Object>> result = jdbcTemplate.queryForList(sql);
  for (Map<String,Object> val: result) {
    System.out.println("=========== "+val.get("id")+" ----- "+val.get("name"));
  }
}
```



## 4. 配置绑定表

相当于mycat的主表子表管理，首先按照order_info的建表顺序创建order_item分别在两个库上建立order_item_1,order_item_2

```shell
CREATE TABLE `order_item_1` (
  `id` int(11) DEFAULT NULL,
  `product_name` varchar(255) DEFAULT NULL,
  `order_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `order_item_2` (
  `id` int(11) DEFAULT NULL,
  `product_name` varchar(255) DEFAULT NULL,
  `order_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

![](/assets/images/2020/icoding/mysql/order-item.jpg)

配置绑定表，将两个item表的分片逻辑和order_info保持一致

```shell
# 给两个数据源命名
spring.shardingsphere.datasource.names=ds0,ds1
# 数据源链接ds0要和命名一致
spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds0.jdbcUrl=jdbc:mysql://39.103.163.215:3306/shard_order
spring.shardingsphere.datasource.ds0.username=gavin
spring.shardingsphere.datasource.ds0.password=123456
# 数据源链接ds1要和命名一致
spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.ds1.jdbcUrl=jdbc:mysql://39.101.221.95:3306/shard_order
spring.shardingsphere.datasource.ds1.username=gavin
spring.shardingsphere.datasource.ds1.password=123456

# 具体的分片规则,基于数据节点
spring.shardingsphere.sharding.tables.order_info.actual-data-nodes=ds$->{0..1}.order_info_$->{1..2}
# 分库的规则
spring.shardingsphere.sharding.tables.order_info.database-strategy.inline.sharding-column=id
spring.shardingsphere.sharding.tables.order_info.database-strategy.inline.algorithm-expression=ds$->{id % 2}
# 分表的规则
spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.sharding-column=user_id
spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.algorithm-expression=order_info_$->{user_id % 2 + 1}

# 具体的分片规则,基于数据节点
spring.shardingsphere.sharding.tables.order_item.actual-data-nodes=ds$->{0..1}.order_item_$->{1..2}
# 分库的规则
spring.shardingsphere.sharding.tables.order_item.database-strategy.inline.sharding-column=order_id
spring.shardingsphere.sharding.tables.order_item.database-strategy.inline.algorithm-expression=ds$->{order_id % 2}
# 分表的规则
spring.shardingsphere.sharding.tables.order_item.table-strategy.inline.sharding-column=user_id
spring.shardingsphere.sharding.tables.order_item.table-strategy.inline.algorithm-expression=order_item_$->{user_id % 2 + 1}

# 绑定表关系
spring.shardingsphere.sharding.binding-tables=order_info,order_item

# 广播表
spring.shardingsphere.sharding.broadcast-tables=province_info
```

> 作业：自己配置使用一个绑定表来进行插入数据和查询数据

```java
// 绑定表插入数据
@Test
void insertOrder(){
  OrderInfo orderInfo = new OrderInfo();
  orderInfo.setId(4).setUserId(10).setOrderStatus(1).setOrderAmount(BigDecimal.valueOf(2499));
  orderInfoService.save(orderInfo);

  OrderItem orderItem = new OrderItem();
  orderItem.setId(2).setOrderId(4).setProductName("易跑跑步机GTS6").setUserId(10);
  orderItemService.save(orderItem);
}
```



## 5. 读写分离配置

首先配置properties的数据源，如果有主机配置就必须要有从机配置

官网配置参考:[https://shardingsphere.apache.org/document/legacy/4.x/document/cn/manual/sharding-jdbc/configuration/config-spring-boot/](https://shardingsphere.apache.org/document/legacy/4.x/document/cn/manual/sharding-jdbc/configuration/config-spring-boot/)

```properties
# 指定主从的配置节点
spring.shardingsphere.datasource.names=master0,master0slave0,master1,master1slave0
# master0数据源链接配置
spring.shardingsphere.datasource.master0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.master0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master0.jdbcUrl=jdbc:mysql://39.103.163.215:3306/shard_order
spring.shardingsphere.datasource.master0.username=gavin
spring.shardingsphere.datasource.master0.password=123456
# master0slave0数据源链接配置
spring.shardingsphere.datasource.master0slave0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.master0slave0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master0slave0.jdbcUrl=jdbc:mysql://39.99.212.46:3306/shard_order
spring.shardingsphere.datasource.master0slave0.username=gavin
spring.shardingsphere.datasource.master0slave0.password=123456
# master1数据源链接配置
spring.shardingsphere.datasource.master1.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.master1.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master1.jdbcUrl=jdbc:mysql://39.101.221.95:3306/shard_order
spring.shardingsphere.datasource.master1.username=gavin
spring.shardingsphere.datasource.master1.password=123456
# master1slave0数据源链接配置
spring.shardingsphere.datasource.master1slave0.type=com.zaxxer.hikari.HikariDataSource
spring.shardingsphere.datasource.master1slave0.driver-class-name=com.mysql.jdbc.Driver
spring.shardingsphere.datasource.master1slave0.jdbcUrl=jdbc:mysql://localhost:3306/shard_order
spring.shardingsphere.datasource.master1slave0.username=root
spring.shardingsphere.datasource.master1slave0.password=gavin

# 具体的分片规则,基于数据节点
spring.shardingsphere.sharding.tables.order_info.actual-data-nodes=ds$->{0..1}.order_info_$->{1..2}
# 分库的规则
spring.shardingsphere.sharding.tables.order_info.database-strategy.inline.sharding-column=id
spring.shardingsphere.sharding.tables.order_info.database-strategy.inline.algorithm-expression=ds$->{id % 2}
# 分表的规则
spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.sharding-column=user_id
spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.algorithm-expression=order_info_$->{user_id % 2 + 1}

# 具体的分片规则,基于数据节点
spring.shardingsphere.sharding.tables.order_item.actual-data-nodes=ds$->{0..1}.order_item_$->{1..2}
# 分库的规则
spring.shardingsphere.sharding.tables.order_item.database-strategy.inline.sharding-column=order_id
spring.shardingsphere.sharding.tables.order_item.database-strategy.inline.algorithm-expression=ds$->{order_id % 2}
# 分表的规则
spring.shardingsphere.sharding.tables.order_item.table-strategy.inline.sharding-column=user_id
spring.shardingsphere.sharding.tables.order_item.table-strategy.inline.algorithm-expression=order_item_$->{user_id % 2 + 1}

# 绑定表关系
spring.shardingsphere.sharding.binding-tables=order_info,order_item

# 广播表
spring.shardingsphere.sharding.broadcast-tables=province_info

# 读写分离主从关系绑定
spring.shardingsphere.sharding.master-slave-rules.ds0.master-data-source-name=master0
spring.shardingsphere.sharding.master-slave-rules.ds0.slave-data-source-names=master0slave0
# 相当于mycat的schema.xml设置datahost的balance,从库负载均衡的规则,可选值：ROUND_ROBIN，RANDOM，这里是轮询从多个读节点上读取数据，从官网上看到是可以自定义负载均衡的规则的，springcloud的rinbon也支持自定义负载均衡的规则
spring.shardingsphere.sharding.master-slave-rules.ds0.load-balance-algorithm-type=round_robin  

spring.shardingsphere.sharding.master-slave-rules.ds1.master-data-source-name=master1
spring.shardingsphere.sharding.master-slave-rules.ds1.slave-data-source-names=master1slave0
# 相当于mycat的schema.xml设置datahost的balance，从库负载均衡的规则,可选值：ROUND_ROBIN，RANDOM，这里是随机从多个读节点上读取数据
spring.shardingsphere.sharding.master-slave-rules.ds1.load-balance-algorithm-type=random
```

读写分离后，主库从库要自己做主从复制，sharding jdbc是不会帮你把数据写到从库的，mycat也一样的。

源代码：

> 思考题：

在sharding-jdbc里是否有双活的概念？是否像MyCat一样支持热切换，如果不支持，我们如何来解决这个问题？

答：sharding-jdbc没有双活的概念，不支持热切换，它没有mycat 的datahost下面配置多个writehost的概念，sharding-jdbc只是客户端数据源连接的高级管理应用。mysql搭建双主互备模式

## 6. 整合druid连接池注意

<mark>其实sharding-jdbc自己会创建数据连接池的，没必要使用druid连接池</mark>，所以你如果导入了依赖

```xml
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid-spring-boot-starter</artifactId>
	<version>1.1.23</version>
</dependency>
```

那么会使得sharding-jdbc创建数据源时与druid发送冲突，项目启动失败，如果要依然使用druid来监控数据库，那么需要做两步

第一步，去掉`DruidDataSourceAutoConfigure`自动配置

- 不导入druid-spring-boot-starter包，使用

  ```xml
  <dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.20</version>
  </dependency>
  ```

- 或者，启动类排除掉`DruidDataSourceAutoConfigure`自动配置

  ```java
  @SpringBootApplication(exclude={DruidDataSourceAutoConfigure.class})
  ```

第二步，使用JPA做ORM框架，加入如下配置

```java
@Configuration
@EnableConfigurationProperties(JpaProperties.class)
public class DataSourceConfiguration {
	private final JpaProperties jpaProperties;

	private final Environment environment;

	public DataSourceConfiguration(JpaProperties jpaProperties, Environment environment) {
		this.jpaProperties = jpaProperties;
		this.environment = environment;
	}

	@Primary
	@Bean
	public DataSource dataSource() {
		String prefix = "spring.shardingsphere.datasource.";
		String each = this.getDataSourceNames(prefix).get(0);
		try {
			return this.getDataSource(prefix, each);
		} catch (final ReflectiveOperationException ex) {
			throw new ShardingSphereException("Can't find datasource type!", ex);
		}
	}

	@Primary
	@Bean
	public EntityManagerFactory entityManagerFactory() {
		HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
		vendorAdapter.setDatabase(Database.MYSQL);
		vendorAdapter.setGenerateDdl(true);
		vendorAdapter.setShowSql(true);
		LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
		factory.setJpaVendorAdapter(vendorAdapter);
		factory.setPersistenceUnitName("default");
		factory.setPackagesToScan("com.lzm.*");
		factory.setDataSource(this.dataSource());
		factory.setJpaPropertyMap(this.jpaProperties.getProperties());
		factory.afterPropertiesSet();
		return factory.getObject();
	}

	@Bean
	@Primary
	public EntityManager entityManager(EntityManagerFactory entityManagerFactory) {
		return SharedEntityManagerCreator.createSharedEntityManager(entityManagerFactory);
	}

	@Primary
	@Bean
	public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
		JpaTransactionManager txManager = new JpaTransactionManager();
		txManager.setEntityManagerFactory(entityManagerFactory);
		return txManager;
	}

	private List<String> getDataSourceNames(final String prefix) {
		StandardEnvironment standardEnv = (StandardEnvironment) this.environment;
		standardEnv.setIgnoreUnresolvableNestedPlaceholders(true);
		return null == standardEnv.getProperty(prefix + "name")
				? new InlineExpressionParser(standardEnv.getProperty(prefix + "names")).splitAndEvaluate()
				: Collections.singletonList(standardEnv.getProperty(prefix + "name"));
	}

	@SuppressWarnings("unchecked")
	private DataSource getDataSource(final String prefix, final String dataSourceName) throws ReflectiveOperationException {
		Map dataSourceProps = PropertyUtil.handle(this.environment, prefix + dataSourceName.trim(), Map.class);
		Preconditions.checkState(!dataSourceProps.isEmpty(), "Wrong datasource properties!");
		DataSource result = DataSourceUtil.getDataSource(dataSourceProps.get("type").toString(), dataSourceProps);
		DataSourcePropertiesSetterHolder.getDataSourcePropertiesSetterByType(dataSourceProps.get("type").toString())
				.ifPresent(dataSourcePropertiesSetter -> dataSourcePropertiesSetter.propertiesSet(this.environment, prefix, dataSourceName, result));
		return result;
	}
}
```

但我不喜欢JPA这个ORM框架，所以一般不用。

## 7. 分库分表配置类

上面是在application.properties配置分库分表的，也可以使用自定义配置类的方式配置分库分表，参考官网的java配置用户手册：[https://shardingsphere.apache.org/document/legacy/4.x/document/cn/manual/sharding-jdbc/configuration/config-java/](https://shardingsphere.apache.org/document/legacy/4.x/document/cn/manual/sharding-jdbc/configuration/config-java/)

application.yaml配置数据源

```yaml
spirng:
	datasource:
    read0:
      url: jdbc:mysql://10.16.92.97:3306/mcsp_ivc?Unicode=true&characterEncoding=UTF-8&serverTimezone=UTC&zeroDateTimeBehavior=convertToNull&rewriteBatchedStatements=true
      username: mcsp_ivc_user
      password: 55ybGksIh
    write0:
      url: jdbc:mysql://10.16.92.97:3306/mcsp_ivc?Unicode=true&characterEncoding=UTF-8&serverTimezone=UTC&zeroDateTimeBehavior=convertToNull&rewriteBatchedStatements=true
      username: mcsp_ivc_user
      password: 55ybGksIh
    read1:
      url: jdbc:mysql://10.16.92.97:3306/mcsp_rcc?Unicode=true&characterEncoding=UTF-8&serverTimezone=UTC&zeroDateTimeBehavior=convertToNull&rewriteBatchedStatements=true
      username: mcsp_rcc_user
      password: 07yKzoYgz
    write1:
      url: jdbc:mysql://10.16.92.97:3306/mcsp_rcc?Unicode=true&characterEncoding=UTF-8&serverTimezone=UTC&zeroDateTimeBehavior=convertToNull&rewriteBatchedStatements=true
      username: mcsp_rcc_user
      password: 07yKzoYgz
    shard-count: 2
    driver-class-name: com.mysql.jdbc.Driver
```

数据源注册到spring容器，类EnvironmentConfig.java

```java
@Component
public class EnvironmentConfig implements EnvironmentAware, BeanDefinitionRegistryPostProcessor {
    public static Environment environment;
    private static final String PREFIX = "spring.datasource.";

    @Override
    public void setEnvironment(Environment env) {
        environment = env;
    }

    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {
        String shardParam = environment.getProperty(PREFIX + "shard-count");
        int shardCount = Objects.nonNull(shardParam) ? Integer.parseInt(shardParam) : 2;
        String driverClass = environment.getProperty(PREFIX + "driver-class-name");
        for(int i=0;i<shardCount;i++){
            String read = "read" + i + ".";
            String write = "write" + i + ".";
            String readUrl = environment.getProperty(PREFIX + read + "url");
            String readUser = environment.getProperty(PREFIX + read + "username");
            String readPassWord = environment.getProperty(PREFIX + read + "password");
            String writeUrl = environment.getProperty(PREFIX + write + "url");
            String writeUser = environment.getProperty(PREFIX + write + "username");
            String writePassWord = environment.getProperty(PREFIX + write + "password");

            RootBeanDefinition readBeanDefinition = new RootBeanDefinition(DataSource.class);
            configBeanDefinition(readBeanDefinition,"readDataSource" + i, readUser, readPassWord, readUrl);
            readBeanDefinition.getPropertyValues().add("driverClassName", driverClass);
            RootBeanDefinition writeBeanDefinition = new RootBeanDefinition(DataSource.class);
            configBeanDefinition(writeBeanDefinition,"writeDataSource" + i, writeUser, writePassWord, writeUrl);
            writeBeanDefinition.getPropertyValues().add("driverClassName", driverClass);
            beanDefinitionRegistry.registerBeanDefinition("readDataSource" + i, readBeanDefinition);
            beanDefinitionRegistry.registerBeanDefinition("writeDataSource" + i, writeBeanDefinition);
        }

    }

    private void configBeanDefinition(RootBeanDefinition beanDefinition, String name, String user, String passWord, String url){
        beanDefinition.setSource("EnvironmentConfig");
        beanDefinition.getPropertyValues().add("username", user);
        beanDefinition.getPropertyValues().add("password", passWord);
        beanDefinition.getPropertyValues().add("url", url);
        beanDefinition.getPropertyValues().add("name", name);
        beanDefinition.setRole(2);
        beanDefinition.setBeanClass(DruidDataSource.class);
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
    }
}
```

分表策略类SingleKeyModuloTableShardingAlgorithm.java，实现精确分片算法接口PreciseShardingAlgorithm.java

```java
public class SingleKeyModuloTableShardingAlgorithm implements PreciseShardingAlgorithm<Long> {
  @Override
  public String doSharding(Collection<String> collection, PreciseShardingValue<Long> shardingValue) {
    String tableName = shardingValue.getLogicTableName(); // 逻辑表名
    // 取分片列值的前6位
    Long key  = Long.valueOf(String.valueOf(shardingValue.getValue()).substring(0, 6));
    return tableName.concat("_").concat(String.valueOf(key)); // 返回具体分片表名
  }
}
```

分表策略类NormalTableShardingAlgorithm.java，实现精确分片算法接口PreciseShardingAlgorithm.java

```java
public class NormalTableShardingAlgorithm implements PreciseShardingAlgorithm<Long> {
    @Override
    public String doSharding(Collection<String> collection, PreciseShardingValue<Long> shardingValue) {
        return shardingValue.getLogicTableName(); // 直接返回逻辑表名
    }
}
```

分库策略类DataBaseShardingAlgorithm.java，实现精确分片算法接口PreciseShardingAlgorithm.java

```java
/**
 * 按租户编码，计算数据库的位置
 */
public class DataBaseShardingAlgorithm implements PreciseShardingAlgorithm<String> {
    @Override
    public String doSharding(Collection<String> collection, PreciseShardingValue<String> shardingValue) {
        String value = shardingValue.getValue();
        int shard = value.hashCode()%collection.size();
        Iterator<String> iterator = collection.iterator();
        int temp = 0;
        String ds = null;
        while(iterator.hasNext()){
            ds = iterator.next();
            if(shard == temp){
                break;
            }
            temp ++;
        }
        return ds; // 返回具体分库名
    }
}
```

配置分库分表总规则，实现ApplicationContextAware接口（应用上下文感知），可以获取spring容器对象

```java
@Configuration
public class ShardingJdbcConfig implements ApplicationContextAware {
  private static final String PREFIX = "spring.datasource.";
  private static ApplicationContext applicationContext;

  @Bean(name = "shardingDataSource")
  @Primary // 优先匹配的bean
  public DataSource getShardingDataSource() throws SQLException {
    // 配置读写分离
    Set<MasterSlaveRuleConfiguration> masterSlaveRuleConfigurationSet = fillDataSource(); // 获取做了主从关系绑定的数据库节点集合
    ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();
    shardingRuleConfig.setMasterSlaveRuleConfigs(masterSlaveRuleConfigurationSet);

    // 需要配置分片规则的表
    TableRuleConfiguration ivc_invoice_header = getTableRule("ivc_invoice_header",  "ds_${0..1}.ivc_invoice_header_${2021..2021}${['05']}","id");
    shardingRuleConfig.getTableRuleConfigs().add(ivc_invoice_header);

    TableRuleConfiguration ivc_invoice_lines = getTableRule("ivc_invoice_lines",  "ds_${0..1}.ivc_invoice_lines_${2021..2021}${['05']}","invoice_id");
    shardingRuleConfig.getTableRuleConfigs().add(ivc_invoice_lines);

    TableRuleConfiguration ivc_invoice_log = getTableRule("ivc_invoice_log",  "ds_${0..1}.ivc_invoice_log_${2021..2021}${['05']}","invoice_id");
    shardingRuleConfig.getTableRuleConfigs().add(ivc_invoice_log);

    TableRuleConfiguration ivc_interface_log = getTableRule("ivc_interface_log",  "ds_${0..1}.ivc_interface_log_${2021..2021}${['05']}","invoice_id");
    shardingRuleConfig.getTableRuleConfigs().add(ivc_interface_log);

    TableRuleConfiguration ivc_src_relation = getTableRule("ivc_src_relation",  "ds_${0..1}.ivc_src_relation_${2021..2021}${['05']}","invoice_id");
    shardingRuleConfig.getTableRuleConfigs().add(ivc_src_relation);

    shardingRuleConfig.setDefaultTableShardingStrategyConfig(new NoneShardingStrategyConfiguration());
    // 设置默认数据库，未配置分片规则的表将通过默认数据源定位
    // shardingRuleConfig.setDefaultDataSourceName("writeDataSource");
    // 默认分表策略，精确分片算法
    ShardingStrategyConfiguration defaultTableConfig = new StandardShardingStrategyConfiguration("id", new NormalTableShardingAlgorithm());
    shardingRuleConfig.setDefaultTableShardingStrategyConfig(defaultTableConfig);
    // 默认分库策略，精确分片算法
    ShardingStrategyConfiguration dataBaseConfig = new StandardShardingStrategyConfiguration("tenant_code", new DataBaseShardingAlgorithm());
    shardingRuleConfig.setDefaultDatabaseShardingStrategyConfig(dataBaseConfig);

    return ShardingDataSourceFactory.createDataSource(createDataSourceMap(), shardingRuleConfig, new Properties()); // 返回
  }
  
  /*
   读写分离规则（配置数据库节点的主从关系绑定）
   */
  private Set<MasterSlaveRuleConfiguration> fillDataSource(){
  Set<MasterSlaveRuleConfiguration> masterSlaveRuleConfigurationSet = new HashSet<>();
  // 分库的数量（数据库节点的数量），没有配置则默认2个数据库节点
  String shardParam = EnvironmentConfig.environment.getProperty(PREFIX + "shard-count");
  int shardCount = Objects.nonNull(shardParam) ? Integer.parseInt(shardParam) : 2;
  for(int i=0;i<shardCount;i++){
    // 数据库节点主从关系绑定配置,ds就是
    MasterSlaveRuleConfiguration masterSlaveRuleConfig =
      new MasterSlaveRuleConfiguration("ds_" + i, "writeDataSource" + i, Arrays.asList("readDataSource" + i));
    masterSlaveRuleConfigurationSet.add(masterSlaveRuleConfig);
  }
  return masterSlaveRuleConfigurationSet;
}
  
  /**
     * 数据源节点Map集合
     */
  private Map<String, DataSource> createDataSourceMap() {
    Map<String, DataSource> result = new HashMap<>();
    String shardParam = EnvironmentConfig.environment.getProperty(PREFIX + "shard-count");
    int shardCount = Objects.nonNull(shardParam) ? Integer.parseInt(shardParam) : 2;
    for(int i=0;i<shardCount;i++){
      // 获取spring容器对象
      DataSource readDataSource = (DataSource)applicationContext.getBean("readDataSource" + i);
      DataSource writeDataSource = (DataSource)applicationContext.getBean("writeDataSource" + i);
      result.put("writeDataSource" + i, writeDataSource);
      result.put("readDataSource" + i, readDataSource);
    }
    return result;
  }
  
  /**
     * 表分片规则配置对象
     */
private TableRuleConfiguration getTableRule(String tableName, String tableNodes, String shardingColumn) {
    TableRuleConfiguration tableRuleConfig = new TableRuleConfiguration(tableName, tableNodes);
    // 分表策略，不设置则使用默认分表策略
    tableRuleConfig.setTableShardingStrategyConfig(
      new StandardShardingStrategyConfiguration(shardingColumn, new SingleKeyModuloTableShardingAlgorithm()));
    return tableRuleConfig;
  }
  
  @Override
  public void setApplicationContext(ApplicationContext context) throws BeansException {
    applicationContext = context;
  }
  
}
```
