---
layout: post
title: 飞天班第9节：SpringBoot操作数据库
category: icoding-edu
tags: [icoding-edu]
keywords: springboot
excerpt: SpringData集成JDBC原理，集成Druid,集成Mybatis,Mybatis的流式查询、传递参数的7种方法
lock: noneed
---

开发网站 = 数据库操作 + web操作 + 模版引擎展示页面（后端 thymleaf [taɪm lif]+ 前端 vue ）

## 1、SpringData简介

数据库操作我们来学习SpringData,无论是使用SQL、NoSQL(NOT ONLY SQL)，在数据库操作底层都是使用SpringData来封装的，它是与SpringBoot、SpringCloud齐名的项目。

官网地址：[https://spring.io/projects/spring-data](https://spring.io/projects/spring-data)

![](/assets/images/2020/icoding/springdata/springdata.gif)

使用IDEA构建项目，选择SQL和NoSQL，可以看到SpringData支持的数据库封装模块

![](/assets/images/2020/icoding/springdata/springdata-sql-nosql.gif)

SpringData 封装大量的xxTemplate供我们直接操作数据库，十分方便，简化了企业开发。

## 2、集成JDBC

1.导入依赖

```xml
<!--点进去，依赖HikariCP 作为默认数据源 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<!--默认版本8.0, 连接数据库url需要配置时区-->
<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <scope>runtime</scope>
</dependency>
```

2.配置application.yml

```yaml
spring:
  datasource:
    username: root
    password: mysql8013
    # 注意8.0以上需要时区的配置
    url: jdbc:mysql://localhost:3306/spring_data_study?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
```

使用idea支持多种数据库的客户端连接，

![](/assets/images/2020/icoding/springdata/idea-datasource.gif)

连接数据库时如果idea没对应数据库的驱动，它会提示下载的

![](/assets/images/2020/icoding/springdata/idea-datasource-driver.gif)

连接mysql，查询表数据

![](/assets/images/2020/icoding/springdata/idea-datasource-console-query-sql.gif)

3.测试链接

在测试类里，我们Autowired（自动装配）引入datasource bean

![](/assets/images/2020/icoding/springdata/springdata-autowired-datasource.gif)

点击上图中的图标，它能帮我们导向自动装配的依赖包，发现是DataSourceConfiguration.class注入bean的，下载它的源码，

![](/assets/images/2020/icoding/springdata/springdata-datasource-configuration.gif)

你会发现除了Hikari DataSource configuration 外，其它都是红色的因为缺失依赖类没生效，我们导入的依赖包spring-boot-starter-jdbc里面有hikari的依赖包，所以Hikari DataSource configuration生效，成为默认的数据源，

![](/assets/images/2020/icoding/springdata/springdata-hikari.gif)

再深入一点，DataSourceConfiguration.class其实一个抽象类，它是在哪里被继承或者调用的？在idea 选择DataSourceConfiguration.class，mac系统按option+F7，window系统按alt+F7,控制台会显示它哪里被引用了

![](/assets/images/2020/icoding/springdata/springdata-datasource-autoconfigure.gif)

发现是DataSourceAutoConfiguration的内部类PooledDataSourceConfiguration，点进去，

![](/assets/images/2020/icoding/springdata/springdata-datasource-autoconfigure2.gif)

是我们熟悉的自动配置类，PooledDataSourceConfiguration 在springboot启动时引入Hikari,Tomcat,Dbcp2等数据源

测试类：

```java
@Autowired
	DataSource dataSource;

	@Test
	void contextLoads() throws SQLException {
		// 查看数据源  class com.zaxxer.hikari.HikariDataSource
		System.out.println(dataSource.getClass());

		// 连接数据库
		Connection connection = dataSource.getConnection();
		System.out.println(connection);
		// 断开连接
		connection.close();
	}
```

结果：

![](/assets/images/2020/icoding/springdata/springdata-hikari-test.gif)

> 小结

spring在连接数据库，我们发现三个自动配置的核心类

DataSourceConfiguration 自动配置的数据源

DataSourceAutoConfiguration 自动配置类

DataSourceProperties 配置文件绑定



4.测试CRUD

使用JdbcTemplate

```java
@RestController
public class JdbcController {
  // jdbcTemplate 会自动帮我们配置完需要的环境，拿来即用
	@Autowired
	JdbcTemplate jdbcTemplate;

	@GetMapping("/list")
	public List<Map<String,Object>> listEmployees(){
		// 耦合性太强，不支持实体类字段名驼峰规则
		String sql ="select * from employee";
		return jdbcTemplate.queryForList(sql);
	}

	// jdbcTemplate 自动帮我们处理了事物
	@GetMapping("/save")
	public String save(){
		String sql = "insert into employee(last_name, email, gender, department, department_name, birth)\n" +
				"value ('jude','74678309@qq.com',1,101,'技术部','"+new Date().toLocaleString()+"')";
		jdbcTemplate.update(sql);
		return "ok";
	}

	// jdbcTemplate 自动帮我们处理了事物
	@GetMapping("/update/{id}")
	public String update(@PathVariable("id") String id){
		String sql = "update employee set last_name =?,email=? where id="+id;
		Object[] params = new Object[2];
		params[0] = "大伟";
		params[1] = "1234567@qq.com";
		jdbcTemplate.update(sql,params);

		return "ok";
	}

	@GetMapping("/delete/{id}")
	public String delete(@PathVariable("id") String id){
		String sql = "delete from employee where id = ?";
		jdbcTemplate.update(sql,id);
		return "ok";
	}
}
```

## 3、集成Druid（德鲁伊）

> 简介

Java程序很大的一部分工作都是要操作数据库的，为了提高操作性能，一般都会使用连接池。Druid就是一个不错的选择，它是阿里巴巴的开源组件之一，集合了C3P0,DBCP的优点，并且**<font color=red>自带日志监控，它可以天然的监控SQL和数据库连接池的状况</font>**

Druid 是一个用 Java 编写的面向列的开源分布式数据存储。 Druid  被设计来快速摄取大量事实数据，并在数据之上提供低延迟查询。Druid  这个名字来自于许多角色扮演游戏中的变形德鲁伊类角色，以反映系统架构可以迁移到解决不同类型的数据问题的特性。 Druid 通常用于商业智能 /  OLAP 应用程序，以分析大量的实时和历史数据。

**<font color=red>任何池化技术，道理都是相通的，配置参数达到更高的性能,可以对比之前学习的线程池</font>**

在Github查看druid的常用配置参数，地址：https://github.com/alibaba/druid/wiki

![](/assets/images/2020/icoding/springdata/springdata-druid-github.gif)

通用配置

```xml
 <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"> 
    <!-- 基本属性 url、user、password -->  
   <property name="url" value="${jdbc_url}" />
     <property name="username" value="${jdbc_user}" />
     <property name="password" value="${jdbc_password}" />

   <!-- 配置监控统计拦截的filters -->
     <property name="filters" value="stat" />

   <!-- 配置初始化大小、最小、最大 ,获取连接等待超时的时间-->
     <property name="initialSize" value="1" />
    	<property name="minIdle" value="1" />
   	 <property name="maxActive" value="20" />
     <property name="maxWait" value="60000" />
    
 <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
     <property name="timeBetweenEvictionRunsMillis" value="60000" />
  <!-- 连接保持空闲而不被驱逐的最小时间 -->
     <property name="minEvictableIdleTimeMillis" value="300000" />

  <!-- 用来检测连接是否有效的sql-->
   	<property name="validationQuery" value="select 1" />
     <property name="testWhileIdle" value="true" />
     <property name="testOnBorrow" value="false" />
     <property name="testOnReturn" value="false" />

  <!--  是否缓存preparedStatement mysql建议关闭-->
     <property name="poolPreparedStatements" value="true" />
     <property name="maxOpenPreparedStatements" value="20" />

     <property name="asyncInit" value="true" />
 </bean>
```

1. 导入log4j,druid依赖，

```xml
<dependency>
			<groupId>com.alibaba</groupId>
			<artifactId>druid</artifactId>
			<version>1.1.20</version>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.17</version>
		</dependency>
```

2. application.yaml配置数据源

```yaml
spring:
  datasource:
    username: root
    password: mysql8013
    # 注意8.0以上需要时区的配置
    url: jdbc:mysql://localhost:3306/spring_data_study?	serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
		initialSize: 5
		minIdle: 1
		maxActive: 20
		maxWait: 60000
		timeBetweenEvictionRunsMillis: 60000
		minEvictableIdleTimeMillis: 300000
		validationQuery: select 1
		testWhileIdle: true
		testOnBorrow: false
		testOnReturn: false
		poolPreparedStatements: true
		maxPoolPreparedStatementPerConnectionSize: 20

#    属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：
#    监控统计用的filter:stat
#    日志用的filter:log4j
#    防御sql注入的filter:wal
    filters: stat,wall,log4j
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
		
```

3. 创建druidConfig，绑定配置，配置监控

```java
@Configuration
public class DruidConfig {
	// 绑定配置
	@ConfigurationProperties(prefix = "spring.datasource")
	@Bean
	public DataSource druidDataSource(){
		return new DruidDataSource();
	}

	// 注册后台监控页面
  @Bean
	public ServletRegistrationBean statViewServlet(){
		ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),"/druid/*");
		Map<String,String> param = new HashMap<>();
		// 后台的登录用户和密码,可以把用户名，密码放到数据库中查询，方便随时修改密码
		param.put(StatViewServlet.PARAM_NAME_USERNAME,"admin");
		param.put(StatViewServlet.PARAM_NAME_PASSWORD,"123456");

		// 访问权限
		// param.put(StatViewServlet.PARAM_NAME_ALLOW,"localhost");    // 多个访问ip用逗号隔开
		param.put(StatViewServlet.PARAM_NAME_ALLOW,""); //为空，所有人都可以访问
		// 拒绝访问
		//param.put(StatViewServlet.PARAM_NAME_DENY,"192.168.12,2");
		bean.setInitParameters(param);

		return bean;
	}
}
```

启动项目，浏览器访问localhost:8080/druid,在登录页面输入配置的账号和密码

![](/assets/images/2020/icoding/springdata/springdata-druid-monitor.gif)

你执行的sql，表被查询、更新、delete了多少次都可以监控到

![](/assets/images/2020/icoding/springdata/springdata-druid-monitor-sql.gif)

1. 增加过滤配置

在druidconfig增加过滤器的配置，排除某些请求不被druid监控拦截

```java
// 过滤器配置
	@Bean
	public FilterRegistrationBean webStatFilter(){
		FilterRegistrationBean bean = new FilterRegistrationBean();
		bean.setFilter(new WebStatFilter());
		Map<String,String> param = new HashMap<>();

		// 配置哪些请求可以被过滤
		param.put("exclusions","*.js,*.css,/druid/*"); // 排除

		bean.setInitParameters(param);
		bean.setUrlPatterns(Arrays.asList("/*"));
		return bean;
	}
```



> 小结

在SpringBoot未来的集成中，都是以下套路，这是一种思想：

1、导入pom依赖

2、application.yaml编写一些配置

3、编写Config类

同理SpringCloud套路：

1、导入pom依赖

2、编写一些配置

3、开启一个注解，如@Enablexxx



## 4、集成MyBatis

1.导入依赖

```xml
<!--mybatis是自己写的启动器，不是官方的-->
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>2.1.2</version>
		</dependency>
```

2.编写实体类,dao类和mapper.xml文件

```java
// 部门类
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Department {
    private Integer id;
    private String departmentName;
}

// dao类
@Mapper // 表示这是一个MyBatis的Mapper
@Repository  // dao层使用的
public interface DepartmentMapper {
    // 获取所有的部门信息
    List<Department> listDepartment();

    // 通过id获取部门信息
    Department getDepartment(Integer id);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--绑定接口-->
<mapper namespace="com.jude.demo.mapper.DepartmentMapper">
    <!--绑定接口中的方法-->
    <select id="listDepartment" resultType="Department">
        select * from department
    </select>

    <select id="getDepartment" resultType="Department">
        select * from department where id = #{id}
    </select>
</mapper>
```

3.配置mybatis

```xml
mybatis:
  configuration:
    map-underscore-to-camel-case: true
  type-aliases-package: com.jude.*.entity
  mapper-locations: classpath:/mapper/**/*.xml
```

如果mapper.xml文件是放在java目录下的需要maven过滤资源，builder配置如下

```xml
<!--Maven默认不支持从 src java目录下获取除了代码之外的配置文件，我们需要过滤一下配置！-->
    <build>
        <resources>
            <!-- 配置文件导出 -->
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
```

我的mapper.xml文件是放在resource目录下的，所以不需要maven配置过滤。

4.编写congroller测试

```java
@RestController
public class DepartmentController {
    @Autowired
    DepartmentMapper departmentMapper;

    // 查询全部部门
    @GetMapping("/listDepartment")
    public List<Department> listDepartment(){
        return departmentMapper.listDepartment();
    }

    // 通过id获取部门信息
    @GetMapping("/getDepartment/{id}")
    public Department getDepartment(@PathVariable("id") Integer id){
        return departmentMapper.getDepartment(id);
    }
}
```

数据库连接按上面druid数据源配置不用修改

## 5、Mybatis的流式查询

**流式查询**指的是查询成功后不是返回一个集合而是返回一个迭代器，应用每次从迭代器取一条查询结果。流式查询的好处是能够降低内存使用。

如果没有流式查询，我们想要从数据库取 1000 万条记录而又没有足够的内存时，就不得不分页查询，而分页查询效率取决于表设计，如果设计的不好，就无法执行高效的分页查询。因此流式查询是一个数据库访问框架必须具备的功能。

流式查询的过程当中，数据库连接是保持打开状态的，因此要注意的是：执行一个流式查询后，数据库访问框架就不负责关闭数据库连接了，需要应用在取完数据后自己关闭。

**MyBatis 流式查询接口**	

`MyBatis` 提供了一个叫 `org.apache.ibatis.cursor.Cursor` 的接口类用于流式查询，这个接口继承了 `java.io.Closeable` 和 `java.lang.Iterable` 接口，由此可知：

1. Cursor 是可关闭的；
2. Cursor 是可遍历的。

Cursor 听名字跟sql server的游标类似，Cursor 提供了三个方法：

1. `isOpen()`：用于在取数据之前判断 Cursor 对象是否是打开状态。只有当打开时 Cursor 才能取数据；
2. `isConsumed()`：用于判断查询结果是否全部取完。
3. `getCurrentIndex()`：返回已经获取了多少条数据

因为 Cursor 实现了迭代器接口，因此在实际使用当中，从 Cursor 取数据非常简单：

```java
cursor.forEach(rowObject -> {...});
```

> 举例

下面是一个Mapper类

```java
@Mapper
public interface FooMapper {
    @Select("select * from foo limit #{limit}")
    Cursor<Foo> scan(@Param("limit") int limit);
}
```

方法 scan() 是一个非常简单的查询。通过指定 Mapper 方法的返回值为 Cursor 类型，`MyBatis` 就知道这个查询方法一个流式查询。

然后在Controller层直接调用这个Dao层的scan方法（省略无关的代码）

```java
@GetMapping("foo/scan/0/{limit}")
public void scanFoo(@PathVariable("limit") int limit) throws Exception {
    try (Cursor<Foo> cursor = fooMapper.scan(limit)) { // 1
        cursor.forEach(foo -> {}); // 2
    }
}
```

上面的代码中，fooMapper 是 @Autowired 进来的。注释 1 处调用 scan 方法，得到 Cursor 对象并保证它能最后关闭，jdk8的try with resource写法；2 处则是从 cursor 中取数据。

我们来执行scanFoo（）方法，这时候会报错

```java
java.lang.IllegalStateException: A Cursor is already closed.
```

这是因为我们前面说了在取数据的过程中需要保持数据库连接，而 Mapper 方法通常在执行完后连接就关闭了（具体可以查看注解@Mapper的源码），因此 Cusor 也一并关闭了。所以我们要保持数据库连接打开的，有三种方案

- 方案一：SqlSessionFactory

  我们可以用 SqlSessionFactory 来手工打开数据库连接，将 Controller 方法修改如下：

  ```java
  @GetMapping("foo/scan/1/{limit}")
  public void scanFoo1(@PathVariable("limit") int limit) throws Exception {
      try (
          SqlSession sqlSession = sqlSessionFactory.openSession(); // 1
          Cursor<Foo> cursor =
                sqlSession.getMapper(FooMapper.class).scan(limit) // 2
      ) {
          cursor.forEach(foo -> { });
      }
  }
  ```

  上面的代码中，1 处我们开启了一个 SqlSession （实际上也代表了一个数据库连接），并保证它最后能关闭；2 处我们使用 SqlSession 来获得 Mapper 对象。这样才能保证得到的 Cursor 对象是打开状态的。

  注意这里的try使用了JDK7开始支持的try-with-resource语法，sqlSession和cursor会在使用完后自动关闭连接的，这是编译器在将java源码文件编译为class字节码文件时加上了关闭连接的操作，有兴趣的小伙伴可以反编译class文件认证一下。

- 方案二：TransactionTemplate

  在 Spring 中，我们可以用 TransactionTemplate 来执行一个数据库事务，这个过程中数据库连接同样是打开的，执行完后，数据库连接才关闭，这就是Spring的 xxxTemplate模版技术，简化开发的思想。代码如下：

  ```java
  @GetMapping("foo/scan/2/{limit}")
  public void scanFoo2(@PathVariable("limit") int limit) throws Exception {
      TransactionTemplate transactionTemplate =
              new TransactionTemplate(transactionManager); // 1
  
      transactionTemplate.execute(status -> { // 2
          try (Cursor<Foo> cursor = fooMapper.scan(limit)) {
              cursor.forEach(foo -> { });
          } catch (IOException e) {
              e.printStackTrace();
          }
          return null;
      });
  }
  ```

  上面的代码中，1 处我们创建了一个 TransactionTemplate 对象（此处 transactionManager 是怎么来的不用多解释，本文假设读者对 Spring 数据库事务的使用比较熟悉了），2 处执行数据库事务，而数据库事务的内容则是调用 Mapper 对象的流式查询。注意这里的 Mapper 对象无需通过 SqlSession 创建，@Autowired由spring容器自动注入。

- 方案三：@Transactional 注解

  这个大家都比较熟悉了，本质上和方案二一样，代码如下：

  ```java
  @GetMapping("foo/scan/3/{limit}")
  @Transactional
  public void scanFoo3(@PathVariable("limit") int limit) throws Exception {
      try (Cursor<Foo> cursor = fooMapper.scan(limit)) {
          cursor.forEach(foo -> { });
      }
  }
  ```

  它仅仅是在原来方法上面加了个 `@Transactional` 注解。这个方案看上去最简洁，**但请注意 Spring 框架当中注解使用的坑：只在外部调用时生效**。在当前类中调用这个方法，依旧会报错。

  以上是三种实现 MyBatis 流式查询的方法。

## 6、Mybatis传递参数的7种方法

### 匿名参数 顺序传递参数

controller

```java
@ApiOperation(value = "多个参数查询_匿名顺序传参")
@GetMapping("findByParams")
public ResultMsg findByParams(Short gender,String age)
{
    List result= employeeMapper.selectByGenderAndAge(gender,age);
    return ResultMsg.getMsg(result);
}
```

mapper

```java
List<Employee> selectByGenderAndAge(Short gender,String age );
```

xml

```xml
<select id="selectByGenderAndAge" resultMap="BaseResultMap" >
  select * from employee where gender = #{gender} and age = #{age}
</select>
```

上面方式按参数名去引用的话会报如下错误，mybatis错误提示很细致，这里明确给我们提示

匿名参数只能使用arg1, arg0, param1, param2 类似的形式

这种传参方式的缺点是不够灵活，必须严格按照参数顺序来引用，<mark>不推荐</mark>

```sh
BindingException: Parameter 'gender' not found. Available parameters are [arg1, arg0, param1, param2]
```

正确方式

```xml
<select id="selectByGenderAndAge" resultMap="BaseResultMap" >
  select *  from employee where gender = #{param1} and age = #{param2}
</select>
```

### 使用@Param注解

controller

```java
@ApiOperation(value = "多个参数查询_注解方式传参")
@GetMapping("findByParams2")
public ResultMsg findByParams2(Short gender,String age)
{
    List result= employeeMapper.selectByGenderAndAge2(gender,age);
    return ResultMsg.getMsg(result);
}
```

mapper

```java
List<Employee> selectByGenderAndAge( @Param("gender") Short gender,@Param("age") String age );
```

xml

```xml
<select id="selectByGenderAndAge" resultMap="BaseResultMap" >
  select * from employee where gender = #{gender} and age = #{age}
</select>
```

### 使用Map

实际开发中使用map来传递多个参数是一种推荐的方式

controller

```java
@ApiOperation(value = "多个参数查询")
@GetMapping("findByMapParams")
public ResultMsg findByMapParams(Short gender,String age)
{
    Map params = new HashMap<>();
    params.put("gender",gender);
    params.put("age",age);
    List result= employeeMapper.selectByMapParams(params);
    return ResultMsg.getMsg(result);
}
```

mapper

```java
List<Employee> selectByMapParams(Map params);
```

xml

```xml
<select id="selectByMapParams" resultMap="BaseResultMap" parameterType="map">
  select * from employee where gender = #{gender} and age = #{age}
</select>
```

可以看到使用map来传递多个参数，可以直接使用参数名称进行引用

### 使用java bean

也可以使用bean的方式来传递多个参数，使用时parameterType指定为对应的bean类型即可。

这就传参方式的优点是比较方便，controller层使用@RequestBody接收到实体类参数后，直接传递给mapper层调用即可，不需要在进行参数的转换

controller

```java
@ApiOperation(value = "多个参数查询_通过Java Bean传递多个参数")
@PostMapping("findByBeans")
public ResultMsg findByBeans(@RequestBody Employee employee)
{
    List result= employeeMapper.selectByBeans(employee);
    return ResultMsg.getMsg(result);
}
```

mapper

```java
List <Employee> selectByBeans(Employee employee);
```

xml

```xml
<select id="selectByBeans" resultMap="BaseResultMap" parameterType="com.wg.demo.po.Employee">
  select * from employee where gender = #{gender} and age = #{age}
</select>
```

### 使用JsonObject

这也是推荐的一种传参方式，controller层收到JSON型数据后，直接传递给mapper层进行查询操作，简单方便，不用定义Java bean(pojo)

controller

```java
@ApiOperation(value = "多个参数查询_通过JSON传递多个参数")
@PostMapping("findByJSONObject")
public ResultMsg findByJSONObject(@RequestBody JSONObject params)
{
    List result= employeeMapper.findByJSONObject(params);
    return ResultMsg.getMsg(result);
}
```

mapper

```java
List <Employee> findByJSONObject(JSONObject params);
```

xml

```xml
<select id="findByJSONObject" resultMap="BaseResultMap" parameterType="com.alibaba.fastjson.JSONObject">
  select * from employee where gender = #{gender} and age = #{age}
</select>
```

### 传递集合类型参数List、Set、Array

在一些复杂的查询中（如 sql中的 in操作），传统的参数传递已无法满足需求，这时候就要用到List、Set、Array类型的参数传递，具体使用如下：

controller

```java
@ApiOperation(value = "多个参数查询_通过List、Set、Array传递多个参数")
@PostMapping("findByList")
public ResultMsg findByList(@RequestBody List<String> list)
{
    List result= employeeMapper.findByList (list);
    return ResultMsg.getMsg(result);
}
```

mapper

```java
List <Employee> findByList(List list);
```

xml

```xml
<select id="findByList" resultMap="BaseResultMap" >
  SELECT * from employee where age in
  <foreach collection="list" open="(" separator="," close=")" item="age">
    #{age}
  </foreach>
</select>
```

这里foreach表示循环操作，具体的参数含义如下：

- foreach元素的属性主要有 item，index，collection，open，separator，close。

- item表示集合中每一个元素进行迭代时的别名

- index指定一个名字，用于表示在迭代过程中，每次迭代到的位置

- open表示该语句以什么开始

- separator表示在每次进行迭代之间以什么符号作为分隔符

- close表示以什么结束

- collection

  在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：

  - 1.如果传入的是单参数且参数类型是一个List的时候，collection属性值为list
  - 2.如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array
  - 3.如果传入的参数是多个的时候，我们就需要把它们封装成一个Map或者Object

测试一下

![](\assets\images\2020\icoding\springdata\mybatis-params-list.png)

### 参数类型为对象+集合

该类参数与java Bean参数形式类似，只不过更复杂一些，如下面的Department类，除了基本字段还包括一个Employee的列表，bean如下

```java
@Data
public class Department {
    private Long id;
    private String deptName;
    private String descr;
    private Date createTime;
    List<Employee> employees;
}
```

controller

```java
@ApiOperation(value = "多个参数查询_对象+集合参数")
@PostMapping("findByDepartment")
public ResultMsg findByDepartment(@RequestBody Department department){
    List result= employeeMapper.findByDepartment(department);
    return ResultMsg.getMsg(result);
}
```

mapper

```java
List <Employee> findByDepartment(@Param("department")Department department);
```

xml

```xml
<select id="findByDepartment" resultMap="BaseResultMap" parameterType="com.wg.demo.po.Department">
    SELECT * from employee where dept_id =#{department.id} and age in
    <foreach collection="department.employees" open="(" separator="," close=")" item="employee">
        #{employee.age}
    </foreach>
</select>
```

这里foreach 对应Departmen部门中的List employees

测试一下

```json
// 请求参数： 查询部门Id=1，并且年龄 等于24和25的员工
{
  "createTime": "2019-07-02T10:17:16.756Z",
  "deptName": "string",
  "descr": "string",
  "employees": [
    {
      "age": "24",
    },
    {
      "age": "25",
    }
  ],
  "id": 1
}
```

结果

```json
{
  "data": [
    {
      "address": "北新街ndcpc",
      "age": "24",
      "createTime": 1562062434000,
      "deptId": "1",
      "gender": 1,
      "id": "318397755696631808",
      "name": "kls0bx19cy"
    },
    {
      "address": "北新街lavi0",
      "age": "25",
      "createTime": 1562062436000,
      "deptId": "1",
      "gender": 1,
      "id": "318397755801489408",
      "name": "gj9q3ygikh"
    }
  ],
  "result": "SUCCESS",
  "resultCode": 200,
  "resultMsg": ""
}
```

